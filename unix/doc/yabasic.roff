.TH YABASIC 1 "yabasic" "4/September/2003" "man page for yabasic derived from yabasic.htm"
.SH NAME
yabasic - yet another Basic
.SH SYNOPSIS
yabasic [options] [filename [arguments]]
.SH DESCRIPTION
Yabasic is a simple, old fashioned basic interpreter with
some additional features, like subroutines and libraries.
Grafics and printing are quite limited but very easy to use.

Yabasic is documented within the file yabasic.htm, which
may or may not be present on your system; in any case this
document can be found on www.yabasic.de.

However, this html-document has been inserted as a preformatted text into this document. Note, that you will at least need an eighty-column terminal to read this text without ugly wrapped lines.

Moreover, the html-document, that is embedded within this man-page contains some chapters, that are specific for windows and do not directly apply to your system.

Finally note, that this man-page (unlike the html-document it is based upon) does not contain hyperlinks. Therefore, if you do not want to read this page as a single piece of text, the only way to navigate it is to search for specific words. There are three especially useful ways to navigate this page; each works by searching for specific strings:

.IP \(bu 4
To go to a specific chapter (e.g. Chapter 5, "All commands and functions of yabasic"), you may look up the number of this chapter in the table of contents and search for the string \fBChapter x.\fR (please note the uppercase "C" and the colon), where \fBx\fR is the number of the chapter. In the example this would be "\fBChapter 5.\fR".

.IP \(bu 4
To go to the description of a specific command (e.g. the \fBfor\fR-command) you may search for its name followed by a single space and a double hyphen. In the example this would be "\fBfor --\fR".

.IP \(bu 4
The description of functions contain the name of the function followed by braces ("\fB()\fR"). Therefore, to find the description of the sine-function, you should search for "\fBsin() --\fR".

.in 1v

But now for the documentation itself:    

.nf

>  
>  Yabasic
>       _________________________________________________________________
>  
>     Table of Contents
>  
>     1. Introduction
>  
>          About this document
>          About yabasic
>  
>     2. The yabasic-program under Windows
>  
>          Starting yabasic
>          Options
>          The context Menu
>  
>     3. The yabasic-program under Unix
>  
>          Starting yabasic
>          Options
>          Setting defaults
>  
>     4. Some features of yabasic, grouped by topic
>  
>          print, input and others
>          Control statements: loops, if and switch
>          Drawing and painting
>          Reading from and writing to files
>          Subroutines and Libraries
>          String processing
>          Arithmetic
>          Data and such
>          Other interesting commands.
>  
>     5. All commands and functions of yabasic
>  
>          A note on the synopsis-sections of reference-entries.
>          A
>          B
>          C
>          D
>          E
>          F
>          G
>          H
>          I
>          L
>          M
>          N
>          O
>          P
>          R
>          S
>          T
>          U
>          V
>          W
>          X
>          Special characters
>  
>     6. A grab-bag of some general concepts and terms
>  
>          Logical shortcuts
>          Conditions and expressions
>          References on arrays
>          Specifying Filenames under Windows
>          Escape-sequences
>  
>     7. A few example programs
>  
>          A very simple program
>          A part of the demo of yabasic
>  
>     8. The Copyright of yabasic
>  
>  Chapter 1. Introduction
>  
>     Table of Contents
>  
>     About this document
>     About yabasic
>  
>  About this document
>  
>     This  document  describes yabasic. You will find information about the
>     yabasic  interpreter  (the  program  yabasic under Unix or yabasic.exe
>     under Windows) as well as the language itself.
>  
>     This document applies to version 2.730 of yabasic
>  
>     However,  this document does not contain the latest news about yabasic
>     or a FAQ. As such information tends to change rapidly, it is presented
>     online only at www.yabasic.de.
>  
>     Although  basic  has  its  reputation  as  a  language  for  beginning
>     programmers,  this  is  not  an  introduction to programming at large.
>     Rather  this  text  assumes,  that  the  reader  has  some  (moderate)
>     experience with writing and starting computer programs.
>  
>  About yabasic
>  
>     yabasic is a traditional basic interpreter. It understands most of the
>     typical  basic-constructs,  like goto, gosub, line numbers, read, data
>     or  string-variables  with  a  trailing  '$'.  But  on the other hand,
>     yabasic  implements  some  more  advanced  programming-constructs like
>     subroutines  or  libraries  (but  not objects). yabasic works much the
>     same under Unix and Windows.
>  
>     yabasic  puts emphasis on giving results quickly and easily; therefore
>     simple  commands  are  provided  to  open  a graphic window, print the
>     graphics  or  control  the  console  screen  and get keyboard or mouse
>     information.  The  example  below  opens  a window, draws a circle and
>     prints the graphic:
>  open window 100,100
>  open printer
>  circle 50,50,40
>  text 10,50,"Press any key to get a printout"
>  clear screen
>  inkey$
>  close printer
>  close window
>  
>     This  example  has  fewer  lines,  than  it  would  have in many other
>     programming  languages.  In  the end however yabasic lacks behind more
>     advanced and modern programming languages like C++ or Java. But as far
>     as it goes it tends to give you results more quickly and easily.
>  
>  Chapter 2. The yabasic-program under Windows
>  
>     Table of Contents
>  
>     Starting yabasic
>     Options
>     The context Menu
>  
>  Starting yabasic
>  
>     Once, yabasic has been set up correctly, there are three ways to start
>     it:
>      1. Rightclick  on  your  desktop:  The  desktop  menu  appears with a
>         submenu  named  new.  From  this submenu choose yabasic. This will
>         create a new icon on your desktop. If you rightclick on this icon,
>         its  context  menu  will  appear;  choose  Execute  to execute the
>         program.
>      2. As  a  variant of the way described above, you may simply create a
>         file  with  the  ending  .yab  (e.g.  with  your favorite editor).
>         Everything else then works as described above.
>      3. From  the  start-menu:  Choose  yabasic  from  your  start-menu. A
>         console-window  will  open  and  you will be asked to type in your
>         program. Once you are finished, you need to type return twice, and
>         yabasic will parse and execute your program.
>  
>  Note
>         This is not the preferred way of starting yabasic ! Simply because
>         the  program,  that  you  have typed, can not be saved and will be
>         lost  inevitably  !  There  is no such thing as a save-command and
>         therefore  no  way  to  conserve the program, that you have typed.
>         This mode is only intended for quick hacks, and short programs.
>  
>  Options
>  
>     Under  Windows yabasic will mostly be invoked by double-clicking on an
>     appropriate  icon; this way you do not have a chance to specify any of
>     the commandline options below. However, advanced users may add some of
>     those options to the appropriate entries in the registry.
>  
>     All  the options below may be abbreviated, as long as the abbreviation
>     does  not  become ambiguous.  For example, you may write -e instead of
>     -execute.
>  
>     -help or -?
>            Prints a short help message, which itself describes two further
>            help-options.
>  
>     -geometry +X-POSITION+Y-POSITION
>            Sets the position of the graphic window, that is opened by open
>            window (the size of this window, of course, is specified within
>            the open window-command). An example would be -geometry +20+10,
>            which  would place the graphic window 10 pixels below the upper
>            border  and  20  pixels right of the left border of the screen.
>            This value cannot be changed, once yabasic has been started.
>  
>     -font NAME-OF-FONT
>            Name  of  the font, which will be used for graphic-text; can be
>            any  of decorative, dontcare, modern, roman, script, swiss. You
>            may  append  a  fontsize  (measured  in pixels) to any of those
>            fontnames;  for example -font swiss30 chooses a swiss-type font
>            with a size of 30 pixels.
>  
>     -execute A-PROGRAM-AS-A-SINGLE-STRING
>            With  this  option  you  may  specify  some  yabasic-code to be
>            executed  right  away.This  is  useful for very short programs,
>            which  you do not want to save within a file. If this option is
>            given,  yabasic  will not read any code from a file. Let's say,
>            you have forgotten some of the square numbers between 1 and 10;
>            in  this  case  the  command  yabasic  -e  'for a=1 to 10:print
>            a*a:next a' will give you the answer immediately.
>  
>     -infolevel INFOLEVEL
>            Change  the infolevel of yabasic, where INFOLEVEL can be one of
>            debug, note, warning, error and fatal (the default is warning).
>            This option changes the amount of debugging-information yabasic
>            produces.  However,  normally only the author of yabasic (me !)
>            would want to change this.
>  
>     -doc NAME-OF-A-PROGRAM
>            Print  the  embedded  documentation  of  the named program. The
>            embedded  documentation  of  a  program  consists  of  all  the
>            comments  within  the  program,  which  start  with the special
>            keyword  doc.  This  documentation can also be seen by choosing
>            the   corresponding   entry   from   the  context-menu  of  any
>            yabasic-program.
>  
>     -librarypath DIRECTORY-WITH-LIBRARIES
>            Change  the  directory,  wherein libraries will be searched and
>            imported  (with  the  import-command).  See also this entry for
>            more information about the way, libraries are searched.
>  
>  The context Menu
>  
>     Like every other icon under Windows, the icon of every yabasic-program
>     has  a context menu offering the most frequent operations, that may be
>     applied to a yabasic-program.
>  
>     Execute
>            This  will  invoke  yabasic  to  execute your program. The same
>            happens, if you doubleclick on the icon.
>  
>     Edit
>            notepad will be invoked, allowing you to edit your program.
>  
>     View docu
>            This  will  present the embedded documentation of your program.
>            Embedded documentation is created with the special comment doc.
>  
>  Chapter 3. The yabasic-program under Unix
>  
>     Table of Contents
>  
>     Starting yabasic
>     Options
>     Setting defaults
>  
>  Starting yabasic
>  
>     If  your  system  administrator  (vulgo  root)  has  installed yabasic
>     correctly, there are three ways to start it:
>      1. You may use your favorite editor (emacs, vi ?) to put your program
>         into  a file (e.g. foo). Make sure that the very first line starts
>         with  the characters '#!' followed by the full pathname of yabasic
>         (e.g.  '#!/usr/local/bin/yabasic').  This  she-bang-line  ensures,
>         that  your  Unix  will invoke yabasic to execute your program (see
>         also the entry for the hash-character). Moreover, you will need to
>         change the permissions of your yabasic-program foo, e.g. chmod u+x
>         foo.  After  that you may invoke yabasic to invoke your program by
>         simply  typing  foo (without even mentioning yabasic). However, if
>         your  PATH-variable  does  not contain a single dot ('.') you will
>         have to type the full pathname of your program: e.g. /home/ihm/foo
>         (or at least ./foo).
>      2. Save  your  program  into  a file (e.g. foo) and type yabasic foo.
>         This  assumes,  that  the  directory,  where  yabasic  resides, is
>         contained within your PATH-variable.
>      3. Finally  your  may simply type yabasic (maybe it will be necessary
>         to  include its full pathname). This will make yabasic come up and
>         you  will be asked to type in your program. Once you are finished,
>         you  need to type return twice, and yabasic will parse and execute
>         your program.
>  
>  Note
>         This is not the preferred way of starting yabasic ! Simply because
>         the  program,  that  you  have typed, can not be saved and will be
>         lost  inevitably  !  There  is no such thing as a save-command and
>         therefore  no  way  to  conserve the program, that you have typed.
>         This  mode  is  only intended for quick hacks, and short programs,
>         i.e. for using yabasic as some sort of fancy desktop calculator.
>  
>  Options
>  
>     yabasic  accepts  a  number  of  options on the commandline. All these
>     options below may be abbreviated, as long as the abbreviation does not
>     become ambiguous. For example you may write -e instead of -execute.
>  
>     -help or -?
>            Prints a short help message, which itself describes two further
>            help-options.
>  
>     -fg FOREGROUND-COLOR or -foreground FOREGROUND-COLOR
>            Define  the foreground color for the graphics-window (that will
>            be  opened  with  open  window). The usual X11 colornames, like
>            red,  green,  ...  are  accepted. This value cannot be changed,
>            once yabasic has been started.
>  
>     -bg BACKGROUND-COLOR or -background BACKGROUND-COLOR
>            Define  the background color for the graphics-window. The usual
>            X11 colornames are accepted. This value cannot be changed, once
>            yabasic has been started.
>  
>     -geometry +X-POSITION+Y-POSITION
>            Sets the position of the graphic window, that is opened by open
>            window  (the  size of this window, of course, is specified with
>            the  open  window-command).  An  example would be +20+10, which
>            would place the graphic window 10 pixels below the upper border
>            and  20  pixels  right  of the left border of the screen. Note,
>            that  the size of the window may not be specified here (well it
>            may,  but  it  will  be  ignored  anyway). This value cannot be
>            changed, once yabasic has been started.
>  
>     -display BACKGROUND-COLOR
>            Specify  the  display,  where  the  graphics  window of yabasic
>            should  appear.  Normally,  however  this value will be already
>            present within the environment variable DISPLAY.
>  
>     -font NAME-OF-FONT
>            Name  of  the  font,  which  will  be  used for text within the
>            graphics window.
>  
>     -execute A-PROGRAM-AS-A-SINGLE-STRING
>            With  this  option  you  may  specify  some  yabasic-code to be
>            executed  right  away.This  is  useful for very short programs,
>            which  you  do  not  want  to save to a file. If this option is
>            given, yabasic will not read any code from a file. E.g.
>  
>  yabasic -e 'for a=1 to 10:print a*a:next a'
>  
>            prints the square numbers from 1 to 10.
>  
>     -infolevel INFOLEVEL
>            Change  the  infolevel of yabasic where INFOLEVEL can be one of
>            debug, note, warning, error and fatal (the default is warning).
>            This option changes the amount of debugging-information yabasic
>            produces.  However,  normally only the author of yabasic (me !)
>            would want to change this.
>  
>     -doc NAME-OF-A-PROGRAM
>            Print  the  embedded  documentation  of  the named program. The
>            embedded  documentation  of  a  program  consists  of  all  the
>            comments  within  the  program,  which  start  with the special
>            keyword doc.
>  
>     -librarypath DIRECTORY-WITH-LIBRARIES
>            Change  the  directory  from  which  libraries will be imported
>            (with  the  import-command).  See  also  this  entry  for  more
>            information about the way, libraries will be searched.
>  
>  Setting defaults
>  
>     If  you  want  to set some options once for all, you may put them into
>     your  X-Windows resource file. This is usually the file .Xresources or
>     some such within your home directory (type man X for details).
>  
>     Here is a sample section, which may appear within this file:
>  yabasic*foreground: blue
>  yabasic*background: gold
>  yabasic*geometry: +10+10
>  yabasic*font: 9x15
>  
>     This  will  set the foreground color of the graphic-window to blue and
>     the background color to gold. The window will appear at position 10,10
>     and the text font will be 9x15.
>  
>  Chapter 4. Some features of yabasic, grouped by topic
>  
>     Table of Contents
>  
>     print, input and others
>     Control statements: loops, if and switch
>     Drawing and painting
>     Reading from and writing to files
>     Subroutines and Libraries
>     String processing
>     Arithmetic
>     Data and such
>     Other interesting commands.
>  
>     This  chapter  has  sections for some of the major features of yabasic
>     and names a few commands related with each area. So, depending on your
>     interest, you find the most important commands of this area named; the
>     other commands from this area may then be discovered through the links
>     in the see also-section.
>  
>  print, input and others
>  
>     The  print-command  is  used to put text on the text screen. Here, the
>     term  text screen stands for your terminal (under Unix) or the console
>     window (under Windows).
>  
>     At  the  bottom  line,  print  simply outputs its argument to the text
>     window.  However,  once  you  have  called  clear  screen  you may use
>     advanced  features  like printing colors or copying areas of text with
>     getscreen$ or putscreen.
>  
>     You  may  ask the user for input with the input-command; use inkey$ to
>     get each key as soon as it is pressed.
>  
>  Control statements: loops, if and switch
>  
>     Of course, yabasic has the goto- and gosub-statements; you may go to a
>     label  or a line number (which is just a special kind of label). goto,
>     despite  its bad reputation ([goto considered harmful]), has still its
>     good  uses;  however  in  many  cases you are probably better off with
>     loops  like  repeat-until, while-wend or do-loop; you may leave any of
>     these  loops  with  the  break-statement  or  start the next iteration
>     immediately with continue.
>  
>     Decisions  can  be made with the if-statement, which comes either in a
>     short  and a long form. The short form has no then-keyword and extends
>     up to the end of the line. The long form extends up to the final endif
>     and  may  use  some  of  the  keywords then (which introduces the long
>     form), else or elsif.
>  
>     If you want to test the result of an expression against many different
>     values, you should probably use the switch-statement.
>  
>  Drawing and painting
>  
>     You  need to call open window before you may draw anything with either
>     line,  circle  or  rectangle; all of these statements may be decorated
>     with  clear  or  fill.  Note  however, that all graphics in yabasic is
>     monochrome  ("black  on  white"). Moreover, there can only be a single
>     window open at any given moment in time.
>  
>     Evyerything you have drawn can be send to your printer too, if you use
>     the open printer command.
>  
>     To allow for some (very) limited version of animated graphics, yabasic
>     offers  the  commands  getbit$  and putbit, which retrieve rectangular
>     regions from the graphics-window into a string or vice versa.
>  
>     If you want to sense mouse-clicks, you may use the inkey$-function.
>  
>  Reading from and writing to files
>  
>     Before you may read or write a file, you need to open it; once you are
>     done,  you  should  close it. Each open file is designated by a simple
>     number,  which  might be stored within a variable and must be supplied
>     if  you want to access the file. This is simply done by putting a hash
>     ('#')  followd  by the number of the file after the keyword input (for
>     reading from) or print (for writing to a file) respectively.
>  
>     If  you  need  more  control, you may consider reading and writing one
>     byte at a time, using the multi-purpose commands peek and poke.
>  
>  Subroutines and Libraries
>  
>     The   best  way  to  break  any  yabasic-program  into  smaller,  more
>     manageable  chunks  are  subroutines and libraries. They are yabasic's
>     most advanced means of structuring a program.
>  
>     Subroutines  are  created with the command sub. they accept parameters
>     and  may  return  a  value.  Subroutines  can  be called much like any
>     builtin  function  of  yabasic;  therefore  they  allow  to extend the
>     language itself.
>  
>     Once  you  have created a set of related subroutines and you feel that
>     they  could be useful in other programs too, you may collect them into
>     a  library. Such a library is contained within a separate file and may
>     be included in any of your programs, using the keyword import.
>  
>  String processing
>  
>     yabasic has the usual functions to extract parts from a string: left$,
>     mid$  and right$. Note, that all of them can be assigned to, i.e. they
>     may change part of a string.
>  
>     If you want to split a string into tokens you should use the functions
>     token or split.
>  
>     There  is  quite  a  bunch  of  other string-processing functions like
>     upper$  (converting  to  upper case), instr (finding one string within
>     the  other),  chr$  (converting  an ascii-code into a character), glob
>     (testing a string against a pattern) and more. Just follow the links.
>  
>  Arithmetic
>  
>     Yabasic   handles   numbers   and   arithmetic:   You   may  calculate
>     trigonometric  functions  like  sin or atan, or logarithms (with log).
>     Bitwise  operations,  like  and or or are available as well min or max
>     (calculate  the  minimum  or  maximum  of  its argument) or mod or int
>     (reminder of a division or integer part or a number).
>  
>  Data and such
>  
>     You  may store data within your program within data-statements; during
>     execution  you  will  probably want to read it into arrays, which must
>     have been dimed before.
>  
>  Other interesting commands.
>  
>       * Yabasic programs may start other programs with the commands system
>         and system$.
>       * peek and poke allow one to get and set internal information; either
>         for the operating system (i.e. Unix or Windows) or yabasic itself.
>       * The  current  time  or  date  can be retrieved with (guess what !)
>         time$ and date$.
>  
>  Chapter 5. All commands and functions of yabasic
>  
>     Table of Contents
>  
>     A note on the synopsis-sections of reference-entries.
>     A
>     B
>     C
>     D
>     E
>     F
>     G
>     H
>     I
>     L
>     M
>     N
>     O
>     P
>     R
>     S
>     T
>     U
>     V
>     W
>     X
>     Special characters
>  
>  A note on the synopsis-sections of reference-entries.
>  
>     Each  reference-entries  to  follow contains a synopsis section, which
>     specifies two things:
>       * The type and number of arguments each function or command accepts.
>       * The type of value (if any) returned by the function.
>  
>     If  possible,  the  name of the variables is choosen to give a hint on
>     their  meaning,  e.g.  a variable might be named colour$, if it should
>     contain a colour.
>  
>     An example:
>  xpos=mousex()
>  xpos=mousex(mouseclick$)
>  
>     This  is  the  synopsis  for  the  mousex-function,  which returns the
>     horizontal screen-position of your mouse-cursor.
>  
>     The  synopsis contains two lines, showing, that mousex might be called
>     with  or  without  an argument and returns a number (see the reference
>     entry for mousex for a description).
>  
>     The  synopsis above contains two variables, whose names give a hint on
>     their meaning:
>       * The  name  mouseclick$  is  chosen,  because  the  mousex-function
>         accepts a string representing a mouse click as returned by inkey$.
>       * The  name  xpos  is chosen, because mousex returns a horizontal or
>         x-position.
>  
>     If  there  is no obvious name for the values accepted or returned by a
>     function or command, a name like a$, x or foo is chosen.
>  
>  A
>  
>     Table of Contents
>  
>     abs() - returns the absolute value of its numeric argument
>     acos() - returns the arcus cosine of its numeric argument
>     and - logical and, used in conditions
>     and() - the bitwise arithmetic and
>     arraydim() - returns the dimension of the array, which is passed as an
>            array reference
>  
>     arraysize() - returns the size of a dimension of an array
>     asc() - accepts a string and returns the position of its first
>            character within the ascii charset
>  
>     asin() - returns the arcus sine of its numeric argument
>     at() - can be used in the print-command to place the output at a
>            specified position
>  
>     atan() - returns the arcus tangens of its numeric argument
>  
>  abs()
>  
>  Name
>  
>     abs() -- returns the absolute value of its numeric argument
>  
>  Synopsis
>  
>  y=abs(x)
>  
>  Description
>  
>     If  the  argument  of  the  abs-function  is  positive  (e.g. 2) it is
>     returned  unchanged,  if  the  argument  is  negative  (e.g. -1) it is
>     returned as a positive value (e.g. 1).
>  
>  Example
>  
>  print abs(-2),abs(2)
>            
>  
>     This example will print 2 2
>  
>  See also
>  
>     sig
>  
>  acos()
>  
>  Name
>  
>     acos() -- returns the arcus cosine of its numeric argument
>  
>  Synopsis
>  
>  x=acos(angle)
>  
>  Description
>  
>     The  acos  is  the  arcus  cosine-function,  i.e.  the  inverse of the
>     cos-function. Or, more elaborate: It Returns the angle (in radian, not
>     degree !), which, fed to the cosine-function will produce the argument
>     passed to the acos-function.
>  
>  Example
>  
>  print acos(0.5),acos(cos(pi))
>            
>  
>     This   example   will  print  1.0472  3.14159  which  are  p/3  and  p
>     respectively.
>  
>  See also
>  
>     cos, asin
>  
>  and
>  
>  Name
>  
>     and -- logical and, used in conditions
>  
>  Synopsis
>  
>  if (a and b) ...
>  while (a and b) ...
>  
>  Description
>  
>     Used  in  conditions  (e.g  within  if,  while  or  until) to join two
>     expressions.  Returns true, if and only if its left and right argument
>     are both true and false otherwise.
>  
>     Note, that logical shortcutsmay take place.
>  
>  Example
>  
>  input "Please enter a number" a
>  if (a>=1 and a<=9) print "your input is between 1 and 9"
>            
>  
>  See also
>  
>     or,not
>  
>  and()
>  
>  Name
>  
>     and() -- the bitwise arithmetic and
>  
>  Synopsis
>  
>  x=and(a,b)
>  
>  Description
>  
>     Used  to  compute the bitwise and of both its argument. Both arguments
>     are treated as binary numbers (i.e. a series of 0 and 1); a bit of the
>     resulting  value  will  then  be 1, if both arguments have a 1 at this
>     position in their binary representation.
>  
>     Note, that both arguments are silently converted to integer values and
>     that  negative  numbers  have  their own binary representation and may
>     lead to unexpected results when passed to and.
>  
>  Example
>  
>  print and(6,3)
>            
>  
>     This  will print 2. This result is clear, if you note, that the binary
>     representation  of  6  and  3  are 110 and 011 respectively; this will
>     yield 010 in binary representaion or 2 as decimal.
>  
>  See also
>  
>     or, eor and not
>  
>  arraydim()
>  
>  Name
>  
>     arraydim() --  returns the dimension of the array, which is passed as
>     an array reference
>  
>  Synopsis
>  
>  a=arraydim(b())
>  
>  Description
>  
>     If  you apply the arraydim()-function on a one-dimensional array (i.e.
>     a vector) it will return 1, on a two-dimensional array (i.e. a matrix)
>     it will return 2, and so on.
>  
>     This  is  mostly  used within subroutines, which expect an array among
>     their parameters. Such subroutines tend to use the arraydim-funtion to
>     check,  if  the  array which has been passed, has the right dimension.
>     E.g.  a  subroutine  to multiply two matrices may want to check, if it
>     really is invoked with two 2-dimensional arrays.
>  
>  Example
>  
>  dim a(10,10),b(10)
>  print arraydim(a()),arraydim(b())
>            
>  
>     This  will  print  2  1, which are the dimension of the arrays a() and
>     b().  You  may  check  out  the  function arraysize for a full-fledged
>     example.
>  
>  See also
>  
>     arraysize and dim.
>  
>  arraysize()
>  
>  Name
>  
>     arraysize() -- returns the size of a dimension of an array
>  
>  Synopsis
>  
>  x=arraysize(a(),b)
>  
>  Description
>  
>     The arraysize-function computes the size of a specified dimension of a
>     specified array. Here, size stands for the maximum number, that may be
>     used  as  an index for this array. The first argument to this function
>     must  be  an reference to an array, the second one specifies, which of
>     the  multiple dimensions of the array should be taken to calculate the
>     size.
>  
>     An  Example  involving  subroutines:  Let's  say,  an  array  has been
>     declared  as  dim  a(10,20)  (that  is  a  two-dimensional  array or a
>     matrix).  If  this  array  is  passed  as  an  array  reference  to  a
>     subroutine,  this  sub  will  not  know,  what  sort of array has been
>     passed.  With  the  arraydim-function the sub will be able to find the
>     dimension of the array, with the arraysize-function it will be able to
>     find  out  the size of this array in its two dimensions, which will be
>     10 and 20 respectively.
>  
>     Our  sample  array  is two dimensional; if you envision it as a matrix
>     this  matrix has 10 lines and 20 columns (see the dim-statement above.
>     To  state  it more formally: The first dimension (lines) has a size of
>     10, the second dimension (columns) has a size of 20; these mumbers are
>     those  returned by arraysize(a(),1) and arraysize(a(),2) respectively.
>     Refer to the example below for a typical usage.
>  
>  Example
>  
>  
>  rem
>  rem  This program adds two matrices elementwise.
>  rem
>  
>  dim a(10,20),b(10,20),c(10,20)
>  
>  rem  initialization of the arrays a() and b() 
>  for y=1 to 10:for x=1 to 20
>     a(y,x)=int(ran(4)):b(y,x)=int(ran(4))
>  next x:next y
>  
>  matadd(a(),b(),c())
>  
>  print "Result:"
>  for x=1 to 20
>     for y=10 to 1 step -1
>        print c(y,x)," ";
>     next y
>     print
>  next x
>  
>  sub matadd(m1(),m2(),r())
>  
>     rem  This sub will add the matrices m1() and m2()
>     rem  elementwise and store the result within r()
>     rem  This is not very useful but easy to implement.
>     rem  However, this sub excels in checking its arguments
>     rem  with arraydim() and arraysize()
>  
>     local x:local y
>     
>     if (arraydim(m1())<>2 or arraydim(m2())<>2 or arraydim(r())<>2) then
>        error "Need two dimensional arrays as input"
>     endif
>  
>     y=arraysize(m1(),1):x=arraysize(m1(),2)
>     if (arraysize(m2(),1)<>y or arraysize(m2(),2)<>x) then
>        error "The two matrices cannot be added elementwise"
>     endif
>  
>     if (arraysize(r(),1)<>y or arraysize(r(),2)<>x) then
>        error "The result cannot be stored in the third argument"
>     endif
>  
>     local xx:local yy
>     for xx=1 to x
>        for yy=1 to y
>           r(yy,xx)=m1(yy,xx)+m2(yy,xx)
>        next yy
>     next xx
>  
>   end sub
>  
>            
>  
>  See also
>  
>     arraydim and dim.
>  
>  asc()
>  
>  Name
>  
>     asc() --  accepts  a  string  and  returns  the position of its first
>     character within the ascii charset
>  
>  Synopsis
>  
>  a=asc(char$)
>  
>  Description
>  
>     The asc-function accepts a string, takes its first character and looks
>     it  up  within  the ascii-charset; this position will be returned. The
>     asc-function  is  the  opposite  of the chr$-function. There are valid
>     uses  for  asc,  however,  comparing  strings (i.e. to bring them into
>     alphabetical sequence) is not among them; in such many cases you might
>     consider  to  compare  strings  directly  with <, = and > (rather than
>     converting a string to a number and comparing this number).
>  
>  Example
>  
>  input "Please enter a letter between 'a' and 'y': " a$
>  if (a$<"a" or a$>"y") print a$," is not in the proper range":end
>  print "The letter after ",a$," is ",chr$(asc(a$)+1)
>            
>  
>  See also
>  
>     chr$
>  
>  asin()
>  
>  Name
>  
>     asin() -- returns the arcus sine of its numeric argument
>  
>  Synopsis
>  
>  angle=asin(x)
>  
>  Description
>  
>     The  acos  is  the  arcus  sine-function,  i.e.  the  inverse  of  the
>     sin-function. Or, more elaborate: It Returns the angle (in radian, not
>     degree  !),  which, fed to the sine-function will produce the argument
>     passed to the asin-function.
>  
>  Example
>  
>  print asin(0.5),asin(sin(pi))
>            
>  
>     This  will  print  0.523599  -2.06823e-13  which  is  p  and  almost 0
>     respectively.
>  
>  See also
>  
>     sin, acos
>  
>  at()
>  
>  Name
>  
>     at() --  can  be  used  in the print-command to place the output at a
>     specified position
>  
>  Synopsis
>  
>  clear screen
>  ...
>  print at(a,b)
>  print @(a,b)
>  
>  Description
>  
>     The  at-clause  takes  two numeric arguments (e.g. at(2,3)) and can be
>     inserted  after  the  print-keyword.  at()  can  be used only if clear
>     screen  has  been executed at least once within the program (otherwise
>     you will get an error).
>  
>     The  two  numeric arguments of the at-function may range from 0 to the
>     width  of  your  terminal  minus  1,  and from 0 to the height of your
>     terminal  minus  1;  if  any argument exceeds these values, it will be
>     truncated  accordingly.  However, yabasic has no influence on the size
>     of  your  terminal (80x25 is a common, but not mandatory), the size of
>     your  terminal  and the maximum values acceptable within the at-clause
>     may  vary.  To  get  the  size  of  your  terminal  you  may  use  the
>     peek-function:  peek("screenwidth") returns the width of your terminal
>     and peek("screenheight") its height.
>  
>  Example
>  
>  clear screen
>  maxx=peek("screenwidth")-1:maxy=peek("screenheight")-1
>  for x=0 to maxx
>    print at(x,maxy*(0.5+sin(2*pi*x/maxx)/2)) "*"
>  next x
>            
>  
>     This  example  plots  a  full  period  of the sine-function across the
>     screen.
>  
>  See also
>  
>     print, clear screen, color
>  
>  atan()
>  
>  Name
>  
>     atan() -- returns the arcus tangens of its numeric argument
>  
>  Synopsis
>  
>  angle=atan(a,b)
>  angle=atan(a)
>  
>  Description
>  
>     The  atan  is  the  arcus-tangens-function,  i.e.  the  inverse of the
>     tan-function. Or, more elaborate: It Returns the angle (in radian, not
>     degree  !),  which,  fed to the tan-function will produce the argument
>     passed to the atan-function.
>  
>     The  atan-function  has  a  second  form, which accepts two arguments:
>     atan(a,b)  which  is (mostly) equivilantly to atan(a/b) except for the
>     fact,  that  the two-argument-form returns an angle in the range -p to
>     p, whereas the one-argument-form returns an angle in the range -p/2 to
>     p/2. To understand this you have to be good at math.
>  
>  Example
>  
>  print atan(1),atan(tan(pi)),atan(-0,-1),atan(-0,1)
>            
>  
>     This  will  print  0.463648 2.06823e-13 -3.14159 3.14159 which is p/4,
>     almost 0, -p and p respectively.
>  
>  See also
>  
>     tan, sin
>  
>  B
>  
>     Table of Contents
>  
>     beep - ring the bell within your computer; a synonym for bell
>     bell - ring the bell within your computer (just as beep)
>     bin$() - converts a number into a sequence of binary digits
>     box - draw a rectancle. A synonym for rectangle
>     break - breaks out of a switch statement or a loop
>  
>  beep
>  
>  Name
>  
>     beep -- ring the bell within your computer; a synonym for bell
>  
>  Synopsis
>  
>  beep
>  
>  Description
>  
>     The  bell-command  rings  the  bell  within  your  computer once. This
>     command  is  not a sound-interface, so you can neither vary the length
>     or  the  height of the sound (technically, it just prints \\a). bell is
>     exactly the same as beep.
>  
>  Example
>  
>  beep:print "This is a problem ..."
>            
>  
>  See also
>  
>     beep
>  
>  bell
>  
>  Name
>  
>     bell -- ring the bell within your computer (just as beep)
>  
>  Synopsis
>  
>  bell
>  
>  Description
>  
>     The  beep-command  rings the bell within your computer once. beep is a
>     synonym for bell.
>  
>  Example
>  
>  print "This is a problem ...":beep
>            
>  
>  See also
>  
>     bell
>  
>  bin$()
>  
>  Name
>  
>     bin$() -- converts a number into a sequence of binary digits
>  
>  Synopsis
>  
>  hexadecimal$=bin$(decimal)
>  
>  Description
>  
>     The  bin$-takes a single numeric argument an converts it into a string
>     of binary digits (i.e. zeroes and ones). If you pass a negative number
>     to bin$, the resulting string will be preceeded by a '-'.
>  
>     If  you  want  to  convert  the  other way around (i.e. from binary to
>     decimal) you may use the dec-function.
>  
>  Example
>  
>  for a=1 to 100
>    print bin$(a)
>  next a
>            
>  
>     This  example prints the binary representation of all digits between 1
>     and 100.
>  
>  See also
>  
>     hex$, dec
>  
>  box
>  
>  Name
>  
>     box -- draw a rectancle. A synonym for rectangle
>  
>  Synopsis
>  
>  See the rectangle-command.
>  
>  Description
>  
>     The  box-command does exactly the same as the rectangle-command; it is
>     just  a  synonym.  Therefore  you  should  refer  to the entry for the
>     rectangle-command for further information.
>  
>  break
>  
>  Name
>  
>     break -- breaks out of a switch statement or a loop
>  
>  Synopsis
>  
>  break
>  
>  Description
>  
>     break  transfers  control  immediately  outside  the enclosing loop or
>     switch  statement.  This  is  the  preferred  way  of leaving a such a
>     statement (rather than goto, which is still possible in most cases).
>  
>  Example
>  
>  for a=1 to 10
>    break
>    print "Hi"
>  next a
>  
>  while(1)
>    break
>    print "Hi"
>  wend
>  
>  repeat
>    break
>    print "Hi"
>  until(0)
>  
>  switch 1
>  case 1:break
>  case 2:case 3:print "Hi"
>  end switch
>            
>  
>     This example prints nothing at all, because each of the loops (and the
>     switch-statement)  does  an immediate break (before it could print any
>     "Hi").
>  
>  See also
>  
>     for, while, repeat and switch.
>  
>  C
>  
>     Table of Contents
>  
>     case - mark the different cases within a switch-statement
>     chr$() - accepts a number and returns the character at this position
>            within the ascii charset
>  
>     circle - draws a circle in the graphic-window
>     clear - Erase circles or rectangles
>     clear screen - erases the text window
>     clear window - clear the graphic window and begin a new page, if
>            prining is under way
>  
>     close - close a file, which has been opened before
>     close curve - close a curve, that has been drawn by the line-command
>     close printer - stops printing of graphics
>     close window - close the graphics-window
>     color - print with color
>     colour - see color
>     compile - compile a string with yabasic-code on the fly
>     continue - start the next iteration of a for-, do-, repeat- or
>            while-loop
>  
>     cos() - return the cosine of its single argument
>  
>  case
>  
>  Name
>  
>     case -- mark the different cases within a switch-statement
>  
>  Synopsis
>  
>  switch a
>    case 1
>    case 2
>    ...
>  end switch
>  
>  ...
>  
>  switch a$
>    case "a"
>    case "b"
>    ...
>  end switch
>  
>  Description
>  
>     Please see the switch-statement.
>  
>  Example
>  
>  input a
>  switch(a)
>    case 1:print "one":break
>    case 2:print "two":break
>    default:print "more"
>  end switch
>            
>  
>     Depending  on  your  input (a number is expected) this code will print
>     one or two or otherwise more.
>  
>  See also
>  
>     switch
>  
>  chr$()
>  
>  Name
>  
>     chr$() -- accepts a number and returns the character at this position
>     within the ascii charset
>  
>  Synopsis
>  
>  character$=chr$(ascii)
>  
>  Description
>  
>     The chr$-function is the opposite of the asc-function. It looks up and
>     returns  the character at the given position within the ascii-charset.
>     It's  typical use is to construct nonprintable characters which do not
>     occur on your keyboard.
>  
>     Nevertheless  you  won't use chr$ as often as you might think, because
>     the  most  important  nonprintable characters can be constructed using
>     escape-sequences  using the \\-character (e.g. you might use \\n instead
>     of chr$(10) wherever you want to use the newline-character).
>  
>  Example
>  
>  print "a",chr$(10),"b"
>            
>  
>     This  will print the letters 'a' and 'b' in different lines because of
>     the intervening newline-character, which is returned by chr$(10).
>  
>  See also
>  
>     asc
>  
>  circle
>  
>  Name
>  
>     circle -- draws a circle in the graphic-window
>  
>  Synopsis
>  
>  circle x,y,r
>  clear circle x,y,r
>  fill circle x,y,r
>  clear fill circle x,y,r
>  
>  Description
>  
>     The  circle-command accepts three parameters: The x- and y-coordinates
>     of the center and the radius of the circle.
>  
>     Some more observations related with the circle-command:
>       * The graphic-window must have been opened already.
>       * The circle may well extend over the boundaries of the window.
>       * If  you  have  issued open printer before, the circle will finally
>         appear in the printed hardcopy of the window.
>       * fill circle will draw a filled (with black ink) circle.
>       * clear circle will erase (or clear) the outline of the circle.
>       * clear fill circle or fill clear circle will erase the full area of
>         the circle.
>  
>  Example
>  
>  open window 200,200
>  
>  for n=1 to 2000
>    x=ran(200)
>    y=ran(200)
>    fill circle x,y,10
>    clear fill circle x,y,8
>  next n
>            
>  
>     This code will open a window and draw 2000 overlapping circles within.
>     Each  circle  is drawn in two steps: First it is filled with black ink
>     (fill  circle x,y,10), then most of this circle is erased again (clear
>     fill  circle  x,y,8).  As a result each circle is drawn with an opaque
>     white  interior  and  a  2-pixel  outline  (2-pixel, because the radii
>     differ by two).
>  
>  See also
>  
>     open window, open printer, line, rectangle
>  
>  clear
>  
>  Name
>  
>     clear -- Erase circles or rectangles
>  
>  Synopsis
>  
>  clear rectangle 10,10,90,90
>  clear fill circle 50,50,20
>  
>  Description
>  
>     May  be  used  within the circle or rectangle command and causes these
>     shapes to be erased (i.e. be drawn in the colour of the background).
>  
>     fill can be used in conjunction with and whereever the fill-clause may
>     appear. Used alone, clear will erase the outline (not the interior) of
>     the  shape  (circle  or rectangle); together with fill the whole shape
>     (including its interior) is erased.
>  
>  Example
>  
>  open window 200,200
>  fill circle 100,100,50
>  clear fill rectangle 10,10,90,90
>            
>  
>     This opens a window and draws a pacman-like figure.
>  
>  See also
>  
>     clear, circle, rectangle
>  
>  clear screen
>  
>  Name
>  
>     clear screen -- erases the text window
>  
>  Synopsis
>  
>  clear screen
>  
>  Description
>  
>     clear  screen  erases  the text window (the window where the output of
>     print appears).
>  
>     It  must be issued at least once, before some advanced screen-commands
>     (e.g.  print  at  or inkey$) may be called; this requirement is due to
>     some  limititations  of  the  curses-library, which is used by yabasic
>     under Unix for some commands.
>  
>  Example
>  
>  clear screen
>  print "Please press a key : ";
>  a$=inkey$
>  print a$
>            
>  
>     The  clear  screen  command is essential here; if it would be omitted,
>     yabasic  would  issue  an  error ("need to call 'clear screen' first")
>     while trying to execute the inkey$-function.
>  
>  See also
>  
>     inkey$
>  
>  clear window
>  
>  Name
>  
>     clear  window --  clear  the  graphic window and begin a new page, if
>     prining is under way
>  
>  Synopsis
>  
>  clear window
>  
>  Description
>  
>     clear  window  clears  the graphic window. If you have started prining
>     the  graphic  via  open printer, the clear window-command starts a new
>     page as well.
>  
>  Example
>  
>  open window 200,200
>  open printer "t.ps"
>  
>  for a=1 to 10
>  if (a>1) clear window
>  text 100,100,"Hallo "+str$(a)
>  next a
>  
>  close printer
>  close window
>            
>  
>     This  example prints 10 pages, with the text "Hello 1", "Hello 2", ...
>     and  so  on.  The  clear screen-command clears the graphics window and
>     starts a new page.
>  
>  See also
>  
>     open window, open printer
>  
>  close
>  
>  Name
>  
>     close -- close a file, which has been opened before
>  
>  Synopsis
>  
>  close filenum
>  close # filenum
>  
>  Description
>  
>     The  close-command  closes an open file. You should issue this command
>     as soon as you are done with reading from or writing to a file.
>  
>  Example
>  
>  open "my.data" for reading as 1
>  input #1 a
>  print a
>  close 1
>            
>  
>     This  program opens the file "my.data", reads a number from it, prints
>     this number and closes the file again.
>  
>  See also
>  
>     open
>  
>  close curve
>  
>  Name
>  
>     close curve -- close a curve, that has been drawn by the line-command
>  
>  Synopsis
>  
>  new curve
>  line to x1,y1
>  ...
>  close curve
>  
>  Description
>  
>     The  close  curve-command  closes  a  sequence of lines, that has been
>     drawn by repeated line to-commands.
>  
>  Example
>  
>  open window 200,200
>  new curve
>  line to 100,50
>  line to 150,150
>  line to 50,150
>  close curve
>            
>  
>     This  example  draws  a  triangle: The three line to-commands draw two
>     lines;  the  final  line is however not drawn explicitly, but drawn by
>     the close curve-command.
>  
>  See also
>  
>     line, new curve
>  
>  close printer
>  
>  Name
>  
>     close printer -- stops printing of graphics
>  
>  Synopsis
>  
>  close printer
>  
>  Description
>  
>     The  close  printer-command  ends  the printing graphics. Between open
>     printer  and  close  printer  everything you draw (e.g. circles, lines
>     ...)  is  sent  to your printer. close printer puts an end to printing
>     and will make your printer eject the page.
>  
>  Example
>  
>  open window 200,200
>  open printer
>  circle 100,100,50
>  close printer
>  close window
>            
>  
>     As  soon  as close printer is executed, your printer will eject a page
>     with a circle on it.
>  
>  See also
>  
>     open printer
>  
>  close window
>  
>  Name
>  
>     close window -- close the graphics-window
>  
>  Synopsis
>  
>  close window
>  
>  Description
>  
>     The  close window-command closes the graphics-window, i.e. it makes it
>     disappear  from your screen. It includes an implicit close printer, if
>     a printer has been opened previously.
>  
>  Example
>  
>  open window 200,200
>  circle 100,100,50
>  close window
>            
>  
>     This  example  will  open a window, draw a circle and close the window
>     again;  all  this  without  any  pause or delay, so the window will be
>     closed before you may regard the circle..
>  
>  See also
>  
>     open window
>  
>  color
>  
>  Name
>  
>     color -- print with color
>  
>  Synopsis
>  
>  print color(fore$) text$
>  print color(fore$,back$) text$
>  
>  Description
>  
>     Not a seperate command, but part of the print-command; may be included
>     just  after  print  and can only be issued after clear screen has been
>     executed.
>  
>     color() takes one or two string-arguments, specifying the color of the
>     text and (optionally) the background.
>  
>     The one or two strings passed to color() can be one of these: "black",
>     "white", "red", "blue", "green", "yellow", "cyan" and "magenta" (which
>     can  be abbreviated as "bla", "whi", "red", "blu", "gre", "yel", "cya"
>     and "mag" respectively).
>  
>     color()  can  only  be  used,  if clear scren has been issued at least
>     once.
>  
>     Note, that color() can be written as colour() too.
>  
>  Example
>  
>  clear screen
>  dim col$(7):for a=0 to 7:read col$(a):next a
>  do
>    print color(col$(ran(7)),col$(ran(7))) " Hallo ";
>    pause 0.01
>  loop
>  data "black","white","red","blue"
>  data "green","yellow","cyan","magenta"
>            
>  
>     This prints the word " Hallo " in all colors accross your screen.
>  
>  See also
>  
>     print, clear screen, at
>  
>  colour
>  
>  Name
>  
>     colour -- see color
>  
>  Synopsis
>  
>  print colour(fore$) text$
>  print colour(fore$,back$) text$
>  
>  See also
>  
>     color
>  
>  compile
>  
>  Name
>  
>     compile -- compile a string with yabasic-code on the fly
>  
>  Synopsis
>  
>  compile(code$)
>  
>  Description
>  
>     This    is   an   advanced   command   (closely   related   with   the
>     execute-command).  It  allows  you to compile a string of yabasic-code
>     (which is the only argument). Afterwards the compiled code is a normal
>     part of your program.
>  
>     Note, that there is no way to remove the compiled code.
>  
>  Example
>  
>  compile("sub mysub(a):print a:end sub")
>  mysub(2)
>            
>  
>     This  example  creates a function named mysub, which simply prints its
>     single argument.
>  
>  See also
>  
>     execute
>  
>  continue
>  
>  Name
>  
>     continue --  start  the  next  iteration  of  a for-, do-, repeat- or
>     while-loop
>  
>  Synopsis
>  
>  continue
>  
>  Description
>  
>     You  may  use  continue  within  any  loop to start the next iteration
>     immediately.  Depending  on  the  type of the loop, the loop-condition
>     will  or  will  not  be checked. Especially: for- and while-loops will
>     evaluate their respective conditions, do- and repeat-loops will not.
>     Remark:  Another way to change the flow of execution within a loop, is
>     the break-command.
>  
>  Example
>  
>  for a=1 to 100
>    if mod(a,2)=0 continue
>    print a
>  next a
>            
>  
>     This example will print all odd numbers between 1 and 100.
>  
>  See also
>  
>     for, do, repeat, while, break
>  
>  cos()
>  
>  Name
>  
>     cos() -- return the cosine of its single argument
>  
>  Synopsis
>  
>  x=cos(angle)
>  
>  Description
>  
>     The cos-function expects an angle (in radian) and returns its cosine.
>  
>  Example
>  
>  print cos(pi)
>            
>  
>     This example will print -1.
>  
>  See also
>  
>     acos, sin
>  
>  D
>  
>     Table of Contents
>  
>     data - introduces a list of data-items
>     date$ - returns a string with various components of the current date
>     dec() - convert a base 2 or base 16 number into decimal form
>     default - mark the default-branch within a switch-statement
>     dim - create an array prior to its first use
>     do - start a (conditionless) do-loop
>     doc - special comment, which might be retrieved by the program itself
>     docu$ - special array, containing the contents of all docu-statement
>            within the program
>  
>     dot - draw a dot in the graphic-window
>  
>  data
>  
>  Name
>  
>     data -- introduces a list of data-items
>  
>  Synopsis
>  
>  data 9,"world"
>  ...
>  read b,a$
>  
>  Description
>  
>     The  data-keyword introduces a list of comma-separated list of strings
>     or numbers, which may be retrieved with the read-command.
>  
>     The  data-command  itself  does nothing; it just stores data. A single
>     data-command  may precede an arbitrarily long list of values, in which
>     strings or numbers may be mixed at will.
>  
>     yabasic  internally  uses  a data-pointer to keep track of the current
>     location  within  the  data-list;  this  pointer may be reset with the
>     restore-command.
>  
>  Example
>  
>  do
>    restore
>    for a=1 to 4
>      read num$,num
>      print num$,"=",num
>    next a
>  loop
>  data "eleven",11,"twelve",12,"thirteen",13,"fourteen",14
>            
>  
>     This example just prints a series of lines eleven=11 up to fourteen=14
>     and so on without end.
>  
>     The  restore-command  ensures that the list of data-items is read from
>     the start with every iteration.
>  
>  See also
>  
>     read, restore
>  
>  date$
>  
>  Name
>  
>     date$ -- returns a string with various components of the current date
>  
>  Synopsis
>  
>  a$=date$
>  
>  Description
>  
>     The  date$-function  (which  must  be called without parantheses; i.e.
>     date$()  would  be  an  error)  returns  a  string  containing various
>     components  of  a date; an example would be 4-05-27-2004-Thu-May. This
>     string consists of various fields separated by hyphens ("-"):
>       * The  day within the week as a number in the range 0 (=sunday) to 6
>         (=saturday) (in the example above: 4, i.e. thursday).
>       * The  month as a number in the range 1 (=january) to 12 (=december)
>         (in the example: 5 which stands for may).
>       * The  day within the month as a number in the range 1 to 31 (in the
>         example: 27).
>       * The  full,  4-digit  year  (in the example: 2004, which reminds me
>         that I should adjust the clock within my computer ...).
>       * The abbreviated name of the day within the week (Mon to Sun).
>       * The abbreviated name of the month (Jan to Dec).
>  
>     Therefore  the  whole example above (4-05-27-2004-Thu-May) would read:
>     day 4 in the week (counting from 0), May 27 in the year 2004, which is
>     a thursday in May.
>  
>     Note, that all fields within the string returned by date$ have a fixed
>     with (numbers are padded with zeroes); therefore it is easy to extract
>     the various fields of a date format with mid$.
>  
>  Example
>  
>  rem   Two ways to print the same ...
>  
>  print mid$(date$,3,10)
>  
>  dim fields$(6)
>  a=split(date$,fields$(),"-")
>  print fields$(2),"-",fields$(3),"-",fields$(4)
>            
>  
>     This example shows two different techniques to extract components from
>     the  value  returned by date$. The mid$-function is the preferred way,
>     but  you  could  just as well split the return-value of date$ at every
>     "-" and store the result within an array of strings.
>  
>  See also
>  
>     time$
>  
>  dec()
>  
>  Name
>  
>     dec() -- convert a base 2 or base 16 number into decimal form
>  
>  Synopsis
>  
>  a=dec(number$)
>  a=dec(number$,base)
>  
>  Description
>  
>     The  dec-function  takes  the  string-representation  of  a  base-2 or
>     base-16  (which  is the default) number and converts it into a decimal
>     number. The optional second argument (base) might be used to specify a
>     base  other  than  16.  However,  currently only base 2 or base 16 are
>     supported.
>  
>  Example
>  
>  input "Please enter a binary number: " a$
>  print a$," is ",dec(a$)
>            
>  
>  See also
>  
>     bin$, hex$
>  
>  default
>  
>  Name
>  
>     default -- mark the default-branch within a switch-statement
>  
>  Synopsis
>  
>  switch a+3
>  case 1
>    ...
>  case 2
>    ...
>  default
>    ...
>  end switch
>  
>  Description
>  
>     The  default-clause  is  an optional part of the switch-statement (see
>     there  for  more  information).  It introduces a series of statements,
>     that should be executed, if none of the casese matches, that have been
>     specified before (each with its own case-clause).
>  
>     So  default  specifies  a  default  to  be  executed,  if  none of the
>     explicitly named cases matches; hence its name.
>  
>  Example
>  
>  print "Please enter a number between 0 and 6,"
>  print "specifying a day in the week."
>  input d
>  switch d
>  case 0:print "Monday":break
>  case 1:print "Tuesday":break
>  case 2:print "Wednesday":break
>  case 3:print "Thursday":break
>  case 4:print "Friday":break
>  case 5:print "Saturday":break
>  case 6:print "Sunday":break
>  default:print "Hey you entered something invalid !"
>  end switch
>            
>  
>     This  program  translates  a number between 0 and 6 into the name of a
>     weekday;  the  default-case  is  used  to  detect (and complain about)
>     invalid input.
>  
>  See also
>  
>     sub, case
>  
>  dim
>  
>  Name
>  
>     dim -- create an array prior to its first use
>  
>  Synopsis
>  
>  dim array(x,y)
>  dim array$(x,y)
>  
>  Description
>  
>     The  dim-command  prepares  one  or  more arrays (of either strings or
>     numbers)  for  later use. This command can also be used to enlarges an
>     existing array.
>  
>     When  an  array is created with the dim-statement, memory is allocated
>     and  all elements are initialized with either 0 (for numerical arrays)
>     or "" (for string arrays).
>  
>     If the array already existed, and the dim-statement specifies a larger
>     size  than the current size, the array is enlarged and any old content
>     is preserved.
>  
>     Note,  that  dim  cannot  be used to shrink an array: If you specify a
>     size,  that  is  smaller  than  the current size, the dim-command does
>     nothing.
>  
>  Example
>  
>  dim a(5,5)
>  for x=1 to 5:for y=1 to 5
>    a(x,y)=int(ran(100))
>  next y:next x
>  printmatrix(a())
>  dim a(7,7)
>  printmatrix(a())
>  
>  sub printmatrix(ar())
>    local x,y,p,q
>    x=arraysize(ar(),1)
>    y=arraysize(ar(),2)
>    for q=1 to y
>      for p=1 to y
>        print ar(p,q),"\\t";
>      next p
>      print
>    next q
>  end sub
>            
>  
>     This  example  creates  a  2-dimenional array (i.e. a matrix) with the
>     dim-statement   and   fills   it   with  random  numbers.  The  second
>     dim-statement enlarges the array, all new elements are filled with 0.
>  
>     The subroutine printmatrix just does, what its name says.
>  
>  See also
>  
>     arraysize, arraydim
>  
>  do
>  
>  Name
>  
>     do -- start a (conditionless) do-loop
>  
>  Synopsis
>  
>  do 
>  ... 
>  loop
>  
>  Description
>  
>     Starts  a loop, which is terminated by loop; everything between do and
>     loop will be repeated forever. This loop has no condition, so it is an
>     infinite  loop; note however, that a break- or goto-statement might be
>     used to leave this loop anytime.
>  
>  Example
>  
>  do
>    a=a+1
>    print a
>    if (a>100) break
>  loop
>            
>  
>     This example prints the numbers between 1 and 101. The break-statement
>     is used to leave the loop.
>  
>  See also
>  
>     loop, repeat, while, break
>  
>  doc
>  
>  Name
>  
>     doc -- special comment, which might be retrieved by the program itself
>  
>  Synopsis
>  
>  doc   This is a comment
>  docu  This is another comment
>  
>  Description
>  
>     Introduces a comment, which spans up to the end of the line. But other
>     than the rem-comment, any docu-comment is collected within the special
>     docu$-array and might be retrieved later on. Moreover you might invoke
>     yabasic  -docu  foo.yab  on  the  commandline to retrieve the embedded
>     documentation within the program foo.yab.
>  
>     Instead of doc you may just as well write docu or even documentation.
>  
>  Example
>  
>  rem   Hi, this has been written by me
>  rem
>  doc   This program asks for a number and
>  doc   prints this number multiplied with 2
>  rem
>  rem   Print out rhe above message
>  for a=1 to arraysize(docu$()):print docu$(a):next a
>  
>  rem   Read and print the number
>  input "Please input a number: " x
>  print x*2
>            
>  
>     This  program  uses  the  comments within its code to print out a help
>     message for the user.
>  
>     The  contents  of the doc-lines are retrieved from the docu$-array; if
>     you  do  not want a comment to be collected within this array, use the
>     rem-statement instead.
>  
>  See also
>  
>     docu$, rem
>  
>  docu$
>  
>  Name
>  
>     docu$ -- special array, containing the contents of all docu-statement
>     within the program
>  
>  Synopsis
>  
>  a$=docu$(1)
>  
>  Description
>  
>     Before  your  program is executed, yabasic collects the content of all
>     the doc-statements within your program within this 1-dimensional array
>     (well only those within the main-program, libraries are skipped).
>  
>     You  may  use  the  arraysize  function to find out, how many lines it
>     contains.
>  
>  Example
>  
>  docu
>  docu  This program reads two numbers 
>  docu  and adds them.
>  docu
>  
>  rem retrieve and print the embedded documentation
>  for a=1 to arraysize(docu$(),1)
>    print docu$(a)
>  next a
>  
>  input "First number: " b
>  input "Second number: " c
>  
>  print "The sum of ",b," and ",c," is ",b+c
>            
>  
>     This program uses the embedded documentation to issue a usage-message.
>  
>  See also
>  
>     arraydim, rem
>  
>  dot
>  
>  Name
>  
>     dot -- draw a dot in the graphic-window
>  
>  Synopsis
>  
>  dot x,y
>  clear dot x,y
>  
>  Description
>  
>     Draws  a  dot at the specified coordinates within your graphic-window.
>     If printing is in effect, the dot appears on your printout too.
>  
>     Use  the  functions  peek("winheight")  or peek("winwidth") to get the
>     size  of  your  window  and  hence  the  boundaries of the coordinates
>     specified for the dot-command.
>  
>  Example
>  
>  open window 200,200
>  circle 100,100,100
>  do
>    x=ran(200):y=ran(200)
>    dot x,y
>    total=total+1
>    if (sqrt((x-100)^2+(y-100)^2)<100) in=in+1
>    print 4*in/total
>  loop
>            
>  
>     This program uses a well known algorithm to compute p.
>  
>  See also
>  
>     line, open window
>  
>  E
>  
>     Table of Contents
>  
>     else - mark an alternative within an if-statement
>     elsif - starts an alternate condition within an if-statement
>     end - terminate your program
>     endif - ends an if-statement
>     end sub - ends a subroutine definition
>     eof - check, if an open file contains data
>     eor() - compute the bitwise exclusive or of its two arguments
>     error - raise an error and terminate your program
>     euler - another name for the constant 2.71828182864
>     execute$() - execute a user defined subroutine, which must return a
>            string
>  
>     execute() - execute a user defined subroutine, which must return a
>            number
>  
>     exit - terminate your program
>     exp() - compute the exponential function of its single argument
>     export - mark a function as globally visible
>  
>  else
>  
>  Name
>  
>     else -- mark an alternative within an if-statement
>  
>  Synopsis
>  
>  if (...) then 
>    ... 
>  else 
>    ... 
>  endif
>  
>  Description
>  
>     The else-statement introduces the alternate branch of an if-statement.
>     I.e.  it  starts the sequence of statements, which is executed, if the
>     condition of the if-statement is not true.
>  
>  Example
>  
>  input "Please enter a number: " a
>  if (mod(a,2)=1) then
>    print a," is odd."
>  else
>    print a," is even."
>  endif
>            
>  
>     This program detects, if the number you have entered is even or odd.
>  
>  See also
>  
>     if
>  
>  elsif
>  
>  Name
>  
>     elsif -- starts an alternate condition within an if-statement
>  
>  Synopsis
>  
>  if (...) then
>    ...
>  elseif (...) 
>    ...
>  elsif (...) then
>    ...
>  else
>    ...
>  endif
>  
>  Description
>  
>     The  elsif-statement  is  used  to select a single alternative among a
>     series of choices.
>  
>     With  each  elsif-statement  you  may  specify  a  condition, which is
>     tested,  if  the  main condition (specified with the if-statement) has
>     failed. Note that elsif might be just as well written as elseif.
>  
>     Within  the  example below, two variables a and b are tested against a
>     range  of  values.  The variable a is tested with the elsif-statement.
>     The  very same tests are performed for the variable b too; but here an
>     involved  series  of  if-else-statements is employed, making the tests
>     much more obscure.
>  
>  Example
>  
>  input "Please enter a number: " a
>  if (a<0) then
>    print "less than 0"
>  elseif (a<=10) then
>    print "between 0 and 10"
>  elsif (a<=20)
>    print "between 11 and 20"
>  else
>    print "over 20"
>  endif
>  
>  input "Please enter another number: " b
>  if (b<0) then
>    print "less than 0"
>  else
>    if (b<=10) then
>      print "between 0 and 10"
>    else
>      if (b<=20) then
>        print "between 11 and 20"
>      else
>        print "over 20"
>      endif
>    endif
>  endif
>            
>  
>     Note,  that  the very same tests are performed for the variables a and
>     b, but can be stated much more clearly with the elsif-statement.
>  
>     Note,  that elsif might be written as elseif too, and that the keyword
>     then is optional.
>  
>  See also
>  
>     if, else
>  
>  end
>  
>  Name
>  
>     end -- terminate your program
>  
>  Synopsis
>  
>  end
>  
>  Description
>  
>     Terminate your program. Much (but not exactly) like the exit command.
>  
>     Note,  that  end  may  not  end  your program immediately; if you have
>     opened  a  window  or  called clear screen, yabasic assumes, that your
>     user  wants  to  study  the output of your program after it has ended;
>     therfore it issues the line ---Program done, press RETURN--- and waits
>     for  a  key to be pressed. If you do not like this behaviour, consider
>     using exit.
>  
>  Example
>  
>  print "Do you want to continue ?"
>  input "Please answer y(es) or n(o): " a$
>  if (lower$(left$(a$,1))="n") then
>    print "bye"
>    end
>  fi
>            
>  
>  See also
>  
>     exit
>  
>  endif
>  
>  Name
>  
>     endif -- ends an if-statement
>  
>  Synopsis
>  
>  if (...) then
>    ...
>  endif
>  
>  Description
>  
>     The endif-statement closes (or ends) an if-statement.
>  
>     Note,  that  endif  may be written in a variety of other ways: end if,
>     end-if or even fi.
>  
>     The  endif-statement  must  be  omitted,  if the if-statement does not
>     contain the keyword then (see the example below). Such an if-statement
>     without endif extends only over a single line.
>  
>  Example
>  
>  input "A number please: " a
>  if (a<10) then
>    print "Your number is less than 10."
>  endif
>  
>  REM  and now without endif 
>  
>  input "A number please: " a
>  if (a<10) print "Your number is less than 10."
>            
>  
>  See also
>  
>     if
>  
>  end sub
>  
>  Name
>  
>     end sub -- ends a subroutine definition
>  
>  Synopsis
>  
>  sub foo(...) 
>    ...
>  end sub
>  
>  Description
>  
>     Marks  the  end  of  a  subroutine-definition  (which  starts with the
>     sub-keyword). The whole concept of subroutines is explained within the
>     entry for sub.
>  
>  Example
>  
>  print foo(3)
>  
>  sub foo(a)
>    return a*2
>  end sub
>            
>  
>     This program prints out 6. The subroutine foo simply returns twice its
>     argument.
>  
>  See also
>  
>     sub
>  
>  eof
>  
>  Name
>  
>     eof -- check, if an open file contains data
>  
>  Synopsis
>  
>  open 1,"foo.bar"
>  if (eof(1)) then 
>     ...
>  end if
>  
>  Description
>  
>     The  eof-function  checks,  if there is still data left within an open
>     file.  As  an  argument  it expects the file-number as returned by (or
>     used within) the open-function (or statement).
>  
>  Example
>  
>  a=open("foo.bar")
>  while(not eof(a)) 
>    input #a,a$
>    print a$
>  end while
>            
>  
>     This  example  will  print  the  contents  of  the file "foo.bar". The
>     eof-function  will  terminate  the loop, if there is no more data left
>     within the file.
>  
>  See also
>  
>     open
>  
>  eor()
>  
>  Name
>  
>     eor() -- compute the bitwise exclusive or of its two arguments
>  
>  Synopsis
>  
>  print eor(a,b)
>  
>  Description
>  
>     The  eor-function  takes  two  arguments  and  computes  their bitwise
>     exclusive  or.  See your favorite introductory text on informatics for
>     an explanation of this function.
>  
>     The xor-function is the same as the eor function; both are synonymous;
>     however they have each their own description, so you may check out the
>     entry of xor for a slightly different view.
>  
>  Example
>  
>  for a=0 to 3
>    for b=0 to 3
>      print fill$(bin$(a))," eor ",fill$(bin$(b))," = ",fill$(bin$(eor(a,b)))
>    next b
>  next a
>  
>  sub fill$(a$)
>    return right$("0"+a$,2)
>  end sub
>            
>  
>     This  example  prints  a  table,  from  which  you may figure, how the
>     eor-function is computed.
>  
>  See also
>  
>     and, or
>  
>  error
>  
>  Name
>  
>     error -- raise an error and terminate your program
>  
>  Synopsis
>  
>  error "Wrong, wrong, wrong !!"
>  
>  Description
>  
>     Produces the same kind or error messages, that yabasic itself produces
>     (e.g.  in case of a syntax-error). The single argument is issued along
>     with the current line-number.
>  
>  Example
>  
>  input "Please enter a number between 1 and 10: " a
>  if (a<1 or a>10) error "Oh no ..."
>            
>  
>     This  program  is  very  harsh in checking the users input; instead of
>     just  asking  again, the program terminates with an error, if the user
>     enters something wrong.
>  
>     The error message would look like this:
>  ---Error in t.yab, line 2: Oh no ...
>  ---Error: Program stopped due to an error
>  
>  See also
>  
>     Well,  there  should  be a corresponding called warning; unfortunately
>     ther is none yet.
>  
>  euler
>  
>  Name
>  
>     euler -- another name for the constant 2.71828182864
>  
>  Synopsis
>  
>  foo=euler
>  
>  Description
>  
>     euler  is the well known constant named after Leonard Euler; its value
>     is  2.71828182864.  euler is not a function, so parens are not allowed
>     (i.e.  euler()  will produce an error). Finally, you may not assign to
>     euler; it wouldn't sense anyway, because it is a constant.
>  
>  Example
>  
>  print euler
>            
>  
>  See also
>  
>     pi
>  
>  execute$()
>  
>  Name
>  
>     execute$() --  execute a user defined subroutine, which must return a
>     string
>  
>  Synopsis
>  
>  print execute$("foo$","arg1","arg2")
>  
>  Description
>  
>     execute$  can be used to execute a user defined subroutine, whose name
>     may be specified as a string expression.
>  
>     This  feature  is  the only way to execute a subroutine, whose name is
>     not  known  by  the time you write your program. This might happen, if
>     you want to execute a subroutine, which is compiled (using the compile
>     command) during the course of execution of your program.
>  
>     Note  however,  that the execute$-function is not the preferred method
>     to execute a user defined subroutine; almost all cases you should just
>     execute  a  subroutine  by  writing  down its name within your yabasic
>     program (see the example).
>  
>  Example
>  
>  print execute$("foo$","Hello","world !")
>  sub foo$(a$,b$)
>    return a$+" "+b$
>  end sub
>            
>  
>     The  example simply prints Hello world !, which is the return value of
>     the  user  defined  subroutine  foo$.  The  same  could be achieved by
>     executing:
>  print foo$(a$,b$)
>  
>  See also
>  
>     compile, execute
>  
>  execute()
>  
>  Name
>  
>     execute() --  execute  a user defined subroutine, which must return a
>     number
>  
>  Synopsis
>  
>  print execute("bar","arg1","arg2")
>  
>  Description
>  
>     The  execute-function  is  the  counterpart  of  the execute$-function
>     (please  see  there  for  some caveats). execute executes subroutines,
>     which returns a number.
>  
>  Example
>  
>  print execute("bar",2,3)
>  sub bar(a,b)
>    return a+b
>  end sub
>            
>  
>  See also
>  
>     compile, execute$
>  
>  exit
>  
>  Name
>  
>     exit -- terminate your program
>  
>  Synopsis
>  
>  exit
>  exit 1
>  
>  Description
>  
>     Terminate  your  program  and  return any given value to the operating
>     system.  exit  is  similar  to end, but it will terminate your program
>     immediately, no matter what.
>  
>  Example
>  
>  print "Do you want to continue ?"
>  input "Please answer y(es) or n(o): " a$
>  if (lower$(left$(a$,1))="n") exit 1
>            
>  
>  See also
>  
>     end
>  
>  exp()
>  
>  Name
>  
>     exp() -- compute the exponential function of its single argument
>  
>  Synopsis
>  
>  foo=exp(bar)
>  
>  Description
>  
>     This  function computes e to the power of its argument, where e is the
>     well known euler constant 2.71828182864.
>  
>     The exp-function is the inverse of the log-function.
>  
>  Example
>  
>  open window 100,100
>  for x=0 to 100
>     dot x,100-100*exp(x/100)/euler
>  next x
>            
>  
>     This  program  plots  part  of  the exp-function, however the range is
>     rather  small,  so  that  you may not recognize the function from this
>     plot.
>  
>  See also
>  
>     log
>  
>  export
>  
>  Name
>  
>     export -- mark a function as globally visible
>  
>  Synopsis
>  
>  export sub foo(bar)
>  ...
>  end sub
>  
>  Description
>  
>     The  export-statement  is used within libraries to mark a user defined
>     subroutine  as  visible  outside  the  library  wherein it is defined.
>     Subroutines,  which  are not exported, must be qualified with the name
>     of the library, e.g. foo.baz (where foo is the name of the library and
>     baz  the  name  of  the  subroutine); exported subroutines may be used
>     without specifying the name of the library, e.g. bar.
>  
>     Therefore export may only be useful within libraries.
>  
>  Example
>  
>     The  library foo.bar (which is listed below) defines two functions bar
>     and  baz,  however  only  the  function  bar is exported and therefore
>     visible  even outside the library; baz is not exported and may only be
>     used within the library foo.yab:
>  export sub bar()
>    print "Hello"
>  end sub
>  
>  sub baz()
>    print "World"
>  end sub
>            
>  
>     Now  within  your  main  program  cux.yab  (which  imports the library
>     foo.yab); note that this program produces an error:
>  import foo
>  
>  print "Calling subroutine foo.bar (okay) ..."
>  foo.bar()
>  print "done."
>  
>  print "Calling subroutine bar (okay) ..."
>  bar()
>  print "done."
>  
>  print "Calling subroutine foo.baz (okay) ..."
>  foo.baz()
>  print "done."
>  
>  print "Calling subroutine baz (NOT okay) ..."
>  baz()
>  print "done."
>  
>     The output when executing yabasic foo.yab is this:
>  Calling subroutine foo.bar (okay) ...
>  Hello
>  done.
>  Calling subroutine bar (okay) ...
>  Hello
>  done.
>  Calling subroutine foo.baz (okay) ...
>  World
>  done.
>  Calling subroutine baz (NOT okay) ...
>  ---Error in main.yab, line 16: can't find subroutine 'baz'
>  ---Dump: sub baz() called in main.yab,16
>  ---Error: Program stopped due to an error
>  
>     As the error message above shows, the subroutine baz must be qualified
>     with  the name of the library, if used outside the library, wherein it
>     is defined (e.g. foo.baz. I.e. outside the library foo.yab you need to
>     write foo.baz. baz alone would be an error.
>  
>     The  subroutine  bar  (without adding the name of the library) however
>     may  (and  probably  should) be used in any program, which imports the
>     library foo.yab.
>  
>  Note
>  
>     In  some  sense  the  set  of  exported  subroutines  constitutes  the
>     interface of a library.
>  
>  See also
>  
>     sub, import
>  
>  F
>  
>     Table of Contents
>  
>     false - a constant with the value of 0
>     fi - another name for endif
>     fill - draw a filled circles or rectangles
>     for - starts a for-loop
>     frac() - return the fractional part of its numeric argument
>  
>  false
>  
>  Name
>  
>     false -- a constant with the value of 0
>  
>  Synopsis
>  
>  okay=false
>  
>  Description
>  
>     The  constant false can be assigned to variables which later appear in
>     conditions (e.g. within an if-statement.
>  
>     false may also be written as FALSE or even FaLsE.
>  
>  Example
>  
>  input "Please enter a number between 1 and 10: " a
>  if (check_input(a)) print "Okay"
>  
>  sub check_input(x)
>    if (x>10 or x<1) return false
>    return true
>  end sub
>            
>  
>     The  subroutine  check_input  checks  its argument and returns true or
>     false according to the outcome of the check..
>  
>  See also
>  
>     true
>  
>  fi
>  
>  Name
>  
>     fi -- another name for endif
>  
>  Synopsis
>  
>  if (...)
>  ...
>  fi
>  
>  Description
>  
>     fi  marks  the  end  of  an  if-statement and is exactly equivilent to
>     endif, please see there for further information.
>  
>  Example
>  
>  input "A number please: " a
>  if (a<10) then
>    print "Your number is less than 10."
>  fi
>            
>  
>  See also
>  
>     endif
>  
>  fill
>  
>  Name
>  
>     fill -- draw a filled circles or rectangles
>  
>  Synopsis
>  
>  fill rectangle 10,10,90,90
>  fill circle 50,50,20
>  
>  Description
>  
>     The  keyword  fill  may be used within the circle or rectangle command
>     and causes these shapes to be filled.
>  
>     fill  can  be  used in conjunction with and whereever the clear-clause
>     may  appear.  Used  alone,  fill  will  fill the interior of the shape
>     (circle  or rectangle); together with clear the whole shape (including
>     its interior) is erased.
>  
>  Example
>  
>  open window 200,200
>  fill circle 100,100,50
>  clear fill rectangle 10,10,90,90
>            
>  
>     This opens a window and draws a pacman-like figure.
>  
>  See also
>  
>     clear, circle, rectangle
>  
>  for
>  
>  Name
>  
>     for -- starts a for-loop
>  
>  Synopsis
>  
>  for a=1 to 100 step 2
>    ...
>  next a
>  
>  Description
>  
>     The  for-loop  lets  its numerical variable (a in the synopsis) assume
>     all  values  within  the  given  range.  The  optional step-clause may
>     specify a value (default: 1) by which the variable will be incremented
>     (or decremented, if step is negative).
>  
>     Any  for-statement  can  be replaced by a set of ifs and gotos; as you
>     may  infer  from  the  example  below  this  is normally not feasable.
>     However if you want to know in detail how the for-statement works, you
>     should  study  this  example,  which  presents  a for-statement and an
>     exactly equivilant series of ifs and gotos.
>  
>  Example
>  
>  for a=1 to 10 step 2:print a:next 
>  
>  a=1
>  label check
>  if (a>10) goto done
>    print a
>    a=a+2
>  goto check
>  label done
>            
>  
>     This  example simply prints the numbers 1, 3, 5, 7 and 9. It does this
>     twice: First with a simple for-statment and then with ifs and gotos.
>  
>  See also
>  
>     step, next
>  
>  frac()
>  
>  Name
>  
>     frac() -- return the fractional part of its numeric argument
>  
>  Synopsis
>  
>  x=frac(y)
>  
>  Description
>  
>     The  frac-function  takes  its argument, removes all the digits to the
>     left of the comma and just returns the digits right of the comma, i.e.
>     the fractional part.
>  
>     Refer  to  the  example  to learn how to rewrite frac by employing the
>     int-function.
>  
>  Example
>  
>  for a=1 to 10
>    print frac(sqr(a))
>    print sqr(a)-int(sqr(a))
>  next a
>            
>  
>     The  example  prints  the  fractional  part  of the square root of the
>     numbers between 1 and 10. Each result is computed (and printed) twice:
>     Once  by  employing  the  frac-function  and  once  by  employing  the
>     int-function.
>  
>  See also
>  
>     int
>  
>  G
>  
>     Table of Contents
>  
>     getbit$() - return a string representing the bit pattern of a
>            rectangle within the graphic window
>  
>     getscreen$() - returns a string representing a rectangular section of
>            the text terminal
>  
>     glob() - check if a string matches a simple pattern
>     gosub - continue execution at another point within your program (and
>            return later)
>  
>     goto - continue execution at another point within your program (and
>            never come back)
>  
>  getbit$()
>  
>  Name
>  
>     getbit$() --  return  a  string  representing  the  bit  pattern of a
>     rectangle within the graphic window
>  
>  Synopsis
>  
>  a$=getbit$(10,10,20,20)
>  a$=getbit$(10,10 to 20,20)
>  
>  Description
>  
>     The  function  getbit  returns  a  string,  which contains the encoded
>     bit-pattern  of  a rectangle within graphic window; the four arguments
>     represent  the  borders  of  the  rectangle. The string returned might
>     later be fed to the putbit-command.
>  
>     The  getbit$-function  might  be used for simple animations (as in the
>     example below).
>  
>  Example
>  
>  open window 40,40
>  fill circle 20,20,18
>  circle$=getbit$(0,0,40,40)
>  close window
>  
>  open window 200,200
>  for x=1 to 200
>    putbit circle$,x,80
>  next x
>            
>  
>     This  example  features  a  circle  moving from left to right over the
>     window.
>  
>  See also
>  
>     putbit
>  
>  getscreen$()
>  
>  Name
>  
>     getscreen$() -- returns a string representing a rectangular section of
>     the text terminal
>  
>  Synopsis
>  
>  a$=getscreen$(2,2,20,20)
>  
>  Description
>  
>     The  getscreen$ function returns a string representing the area of the
>     screen as specified by its four arguments (which specify two corners).
>     I.e. everything you have printed within this rectangle will be encoded
>     in the string returned (including any colour-information).
>  
>     Like most other commands dealing with advanced text output, getscreen$
>     requires, that you have called clear screen before.
>  
>  Example
>  
>  clear screen
>  
>  for a=1 to 1000:
>          print color("red") "1";
>          print color("green") "2";
>          print color("blue") "3";
>  next a  
>  screen$=getscreen$(10,10,40,10)
>  print at(10,10) " Please Press 'y' or 'n' ! "
>  a$=inkey$
>  putscreen screen$,10,10
>            
>  
>     This program fills the screen with coloured digits and afterwards asks
>     the  user  for  a choice ( Please press 'y' or 'n' ! ). Afterwards the
>     area of the screen, which has been overwritten by the question will be
>     restored  with  its  previous  contents,  whhch  had  been  saved  via
>     getscreen$.
>  
>  See also
>  
>     putscreen$
>  
>  glob()
>  
>  Name
>  
>     glob() -- check if a string matches a simple pattern
>  
>  Synopsis
>  
>  if (glob(string$,pattern$)) ...
>  
>  Description
>  
>     The glob-function takes two arguments, a string and a (glob-) pattern,
>     and  checks  if  the string matches the pattern. However glob does not
>     employ  the  powerful rules of regular expressions; rather it has only
>     two  special  characters:  *  (which matches any number (even zero) of
>     characters) and ? (which matches exactly a single character).
>  
>  Example
>  
>  for a=1 to 10
>    read string$,pattern$
>    if (glob(string$,pattern$)) then
>      print string$," matches ",pattern$
>    else
>      print string$," does not match ",pattern$
>    endif
>  next a
>  
>  data "abc","a*"
>  data "abc","a?"
>  data "abc","a??"
>  data "abc","*b*"
>  data "abc","*"
>  data "abc","???"
>  data "abc","?"
>  data "abc","*c"
>  data "abc","A*"
>  data "abc","????"
>            
>  
>     This program checks the string abc against various patterns and prints
>     the result. The output is:
>  abc matches a*
>  abc does not match a?
>  abc matches a??
>  abc matches *b*
>  abc matches *
>  abc matches ???
>  abc does not match ?
>  abc matches *c
>  abc does not match A*
>  abc does not match ????
>  
>  See also
>  
>     There are no related commands.
>  
>  gosub
>  
>  Name
>  
>     gosub -- continue execution at another point within your program (and
>     return later)
>  
>  Synopsis
>  
>  gosub foo
>  
>  ...
>  
>  label foo
>  ...
>  return
>  
>  Description
>  
>     gosub  remembers  the  current  position  within your program and then
>     passes  the  flow  of  execution  to  another point (which is normally
>     marked  with  a label). Later, when a return-statement is encountered,
>     the execution is resumed at the previous location.
>  
>     gosub  is  the traditional command for calling code, which needs to be
>     executed  from  various  places  within  your  program.  However, with
>     subroutines  yabasic  offers  a much more flexible way to achieve this
>     (and more). Therefore gosub must to be considered obsolete.
>  
>  Example
>  
>  print "Do you want to exit ? "
>  gosub ask
>  if (r$="y") exit
>  
>  label ask
>  input "Please answer yes or no, by typing 'y' or 'n': ",r$
>  return
>            
>  
>  See also
>  
>     return, goto, sub, label, on gosub
>  
>  goto
>  
>  Name
>  
>     goto --  continue execution at another point within your program (and
>     never come back)
>  
>  Synopsis
>  
>  goto foo
>  
>  ...
>  
>  label foo
>  
>  Description
>  
>     The  goto-statement  passes  the  flow  of  execution to another point
>     within your program (which is normally marked with a label).
>  
>     goto  is  normally considered obsolete and harmful, however in yabasic
>     it  may  be  put  to the good use of leaving loops (e.g. while or for)
>     prematurely.  Note  however, that subroutines may not be left with the
>     goto-statement.
>  
>  Example
>  
>  print "Please press any key to continue."
>  print "(program will continue by itself within 10 seconds)"
>  for a=1 to 10
>    if (inkey$(1)<>"") then goto done
>  next a
>  label done
>  print "Hello World !"
>            
>  
>     Here the goto-statment is used to leave the for-loop prematurely.
>  
>  See also
>  
>     gosub, on goto
>  
>  H
>  
>     Table of Contents
>  
>     hex$() - convert a number into hexadecimal
>  
>  hex$()
>  
>  Name
>  
>     hex$() -- convert a number into hexadecimal
>  
>  Synopsis
>  
>  print hex$(foo)
>  
>  Description
>  
>     The hex$-function converts a number into a string with its hexadecimal
>     representation. hex$ is the inverse of the dec-function.
>  
>  Example
>  
>  open 1,"foo"
>  while(!eof(1))
>    print right$("0"+hex$(peek(1)),2)," ";
>    i=i+1
>    if (mod(i,10)=0) print
>  end while
>  print
>            
>  
>     This  program  reads  the file foo and prints its output as a hex-dump
>     using the hex-function.
>  
>  See also
>  
>     decbin
>  
>  I
>  
>     Table of Contents
>  
>     if - evaluate a condition and execute statements or not, depending on
>            the result
>  
>     import - import a library
>     inkey$ - wait, until a key is pressed
>     input - read input from the user (or from a file) and assign it to a
>            variable
>  
>     instr() - searches its second argument within the first; returns its
>            position if found
>  
>     int() - return the integer part of its single numeric argument
>  
>  if
>  
>  Name
>  
>     if -- evaluate a condition and execute statements or not, depending on
>     the result
>  
>  Synopsis
>  
>  if (...) then
>    ...
>  endif
>  
>  if (...) ...
>  
>  if (...) then
>    ...
>  else
>    ...
>  endif
>  
>  if (...) then
>    ...
>  elsif (...)
>    ...
>  elsif (...) then
>    ...
>  else
>    ...
>  endif
>  
>  Description
>  
>     The  if-statement  is  used  to evaluate a conditions and take actions
>     accordingly.  (As  an  aside,  please  note  that  there  is  no  real
>     difference between conditions and expressions.)
>  
>     There are two major forms of the if-statement:
>       * The one-line-form without the keyword then:
>  if (...) ...
>         This  form  evaluates  the  condition  and  if  the result is true
>         executes  all commands (separated by colons) upt to the end of the
>         line. There is neither an endif keyword nor an else-branch.
>       * The multi-line-form with the keyword then:
>  if (...) then ... elsif (...) ... else ... endif
>         (where elsif and else are optional, whereas endif is not.
>         According to the requirements of your program, you may specify:
>            + elsif(...),   which  specifies  a  condition,  that  will  be
>              evaluated   only  if  the  condition(s)  whithin  if  or  any
>              preceeding elsif did not match.
>            + else,  which  introduces a sequence of commands, that will be
>              executed, if none of the conditions above did match.
>            + endif is required and ends the if-statement.
>  
>  Example
>  
>  input "Please enter a number between 1 and 4: " a
>  if (a<=1 or a>=4) error "Wrong, wrong !"
>  if (a=1) then
>    print "one"
>  elsif (a=2)
>    print "two"
>  elsif (a=3)
>    print "three"
>  else
>    print "four"
>  endif
>            
>  
>     The  input-number  between 1 and 4 is simply echoed as text (one, two,
>     ...).  The  example  demonstrates  both  forms (short and long) of the
>     if-statement  (Note however, that the same thing can be done, probably
>     somewhat more elegant, with the switch-statement).
>  
>  See also
>  
>     else, elsif, endif, conditions and expressions.
>  
>  import
>  
>  Name
>  
>     import -- import a library
>  
>  Synopsis
>  
>  import foo
>  
>  Description
>  
>     The  import-statment  imports a library. It expects a single argument,
>     which  must be the name of a library (without the trailing .yab). This
>     library  will  then  be  read  and  parsed  and  its  subroutines (and
>     variables) will be made available within the main program.
>  
>     Libraries  will  first  be searched within the current directory (i.e.
>     the  directory  within  which you have invoked yabasic), then within a
>     special  directory,  whose  exact  location  depends  on  your system.
>     Typical  values  would  be /usr/lib under Unix or C:\\yabasic\\lib under
>     Windows.  However  only  yabasic  -help-usage  may tell the truth. The
>     location  of  this  second  directory  may  be changed with the option
>     -library (either under Windows or Unix).
>  
>  Example
>  
>     Lets  say  you have a yabasic-program foo.yab, which imports a library
>     lib.yab. foo.yab reads:
>  import lib
>  
>  rem  This works ...
>  lib.x(0)
>  
>  rem  This works too ..
>  x(1)
>  
>  rem  And this.
>  lib.y(2)
>  
>  rem  But this not !
>  y(3)
>            
>  
>     Now the library lib.yab reads:
>  rem  Make the subroutine x easily available outside this library
>  export sub x(a)
>    print a
>    return
>  end sub
>  
>  rem  sub y must be referenced by its full name
>  rem  outside this library
>  sub y(a)
>    print a
>    return
>  end sub
>  
>     This program produces an error:
>  
>  0
>  1
>  2
>  ---Error in foo.yab, line 13: can't find subroutine 'y'
>  ---Dump: sub y() called in foo.yab,13
>  ---Error: Program stopped due to an error
>  
>     As  you  may see from the error message, yabasic is unable to find the
>     subroutine  y without specifying the name of the library (i.e. lib.y).
>     The reason for this is, that y, other than x, is not exported from the
>     library lib.yab (using the export-statement).
>  
>  See also
>  
>     export, sub
>  
>  inkey$
>  
>  Name
>  
>     inkey$ -- wait, until a key is pressed
>  
>  Synopsis
>  
>  clear screen
>  foo$=inkey$
>  inkey$
>  foo$=inkey$(bar)
>  inkey$(bar)
>  
>  Description
>  
>     The  inkeys$-function  waits,  until  the  user  presses  a key on the
>     keyboard  or  a  button  of  his  mouse, and returns this very key. An
>     optional argument specifies the number of seconds to wait; if omitted,
>     inkey$ will wait indefinitely.
>  
>     inkey$  may  only  be  used,  if clear screen has been called at least
>     once.
>  
>     For  normal  keys, yabasic simply returns the key, e.g. a, 1 or !. For
>     function  keys  you will get f1, f2 and so on. Other special keys will
>     return  these strings respectively: enter, backspace, del, esc, scrnup
>     (for  screen  up),  scrndown and tab. Modifier keys (e.g. ctrl, alt or
>     shift)  by  themself  can not be detected (however, if you press shift
>     and  e.g. a simultaniously, inkey$ will return the letter A instead of
>     a of course).
>  
>     If a graphical window has been opened (via open window) any mouseclick
>     within this window will be returned by inkey$ too. The string returned
>     (e.g.   MB1d+0:0028,0061,  MB2u+0:0028,0061  or  MB1d+1:0028,0061)  is
>     constructed as follows:
>       * Every  string  associated  with  a  mouseclick will start with the
>         fixed string MB
>       * The next digit (1, 2 or 3) specifies the mousebutton pressed.
>       * A  single  letter,  d or u, specifies, if the mousebutton has been
>         pressed  or  released: d stands for down, i.e. the mousebutton has
>         been pressed; u means up, i.e. the mousebutton has been released.
>       * The plus-sign ('+'), which follows is always fixed.
>       * The  next  digit  (in  the range 0 to 7) encodes the modifier keys
>         pressed,  where  1 stands for shift, 2 stands for alt and 4 stands
>         for ctrl.
>       * The next four digits (e.g. 0028) contain the x-position, where the
>         mousebutton has been pressed.
>       * The comma to follow is always fixed.
>       * The last four digits (e.g. 0061) contain the y-position, where the
>         mousebutton has been pressed.
>  
>     All  those  fields  are of fixed length, so you may use functions like
>     mid$  to  extract  certain  fields.  However,  note  that with mousex,
>     mousey,  mouseb and mousemod there are specialized functions to return
>     detailed information about the mouseclick. Finally it should be noted,
>     that  inkey$ will only register mouseclicks within the graphic-window;
>     mouseclicks in the text-window cannot be detected.
>  
>     inkey$  accepts an optional argument, specifying a timeout in seconds;
>     if  no  key has been pressed within this span of time, an empty string
>     is  returned. If the timeout-argument is omitted, inkey$ will wait for
>     ever.
>  
>  Example
>  
>  clear screen
>  open window 100,100
>  print "Press any key or press 'q' to stop."
>  repeat
>    a$=inkey$
>    print a$
>  until(a$="q")
>            
>  
>     This program simply returns the key pressed. You may use it, to learn,
>     which strings are returned for the special keys on your keyboard (e.g.
>     function-keys).
>  
>  See also
>  
>     clear screen,mousex, mousey, mouseb, mousemod
>  
>  input
>  
>  Name
>  
>     input -- read input from the user (or from a file) and assign it to a
>     variable
>  
>  Synopsis
>  
>  input a
>  input a,b,c
>  input a$
>  input "Hello" a
>  input #1 a$
>  
>  Description
>  
>     input  reads  the  new  contents  of one or many (numeric- or string-)
>     variables, either from the keyboard (i.e. from you) or from a file. An
>     optional  first  string-argument  specifies  a  prompt,  which will be
>     issued before reading any contents.
>  
>     If  you  want  to  read  from an open file, you need to specify a hash
>     ('#'), followed by the number, under which the file has been opened.
>  
>     Note,  that  the  input  is split at spaces, i.e. if you enter a whole
>     line    consisting   of   many   space-separated   word,   the   first
>     input-statement  will only return the first word; the other words will
>     only  be returned on subsequent calls to input; the same applies, if a
>     single  input  reads  multiple variables: The first variable gets only
>     the  first  word,  the  second  one the second word, and so on. If you
>     don't  like  this  behaviour,  you may use line input, which returns a
>     whole line (including embedded spaces) at once.
>  
>  Example
>  
>  input "Please enter the name of a file to read: " a$
>  open 1,a$
>  while(!eof(1))
>    input #1 b$
>    print b$
>  wend
>            
>  
>     If  this  program  is stored within a file test.yab and you enter this
>     name when prompted for a file to read, you will see this output:
>  
>  Please enter the name of a file to read: t.yab
>  input
>  "Please
>  enter
>  the
>  name
>  of
>  a
>  file
>  to
>  read:
>  "
>  a$
>  open
>  1,a$
>  while(!eof(1))
>  input
>  #1
>  b$
>  print
>  b$
>  wend
>  
>  See also
>  
>     line input
>  
>  instr()
>  
>  Name
>  
>     instr() -- searches its second argument within the first; returns its
>     position if found
>  
>  Synopsis
>  
>  print instr(a$,b$)
>  if (instr(a$,b$)) ...
>  pos=instr(a$,b$,x)
>  
>  Description
>  
>     The  instr-functions  requires  two  string arguments and searches the
>     second  argument within the first. If the second argument can be found
>     within  the first, the position is returned (counting from one). If it
>     can  not  be  found,  the  instr-function  returns  0; this makes this
>     function  usable  within  the  condition  of  an if-statement (see the
>     example below).
>  
>     If you supply a third, numeric argument to the instr-function, it will
>     be   used   as   a   starting   point   for   the   search.  Therefore
>     instr("abcdeabcdeabcde","e",8)  will return 10, because the search for
>     an  "e" starts at position 8 and finds the "e" at position 10 (and not
>     the one at position 5).
>  
>  Example
>  
>  input "Please enter a text containing the string 'bumf': " a$
>  if (instr(a$,"bumf")) then
>    print "Well done !"
>  else
>    print "not so well ..."
>  endif
>            
>  
>  See also
>  
>     rinstr
>  
>  int()
>  
>  Name
>  
>     int() -- return the integer part of its single numeric argument
>  
>  Synopsis
>  
>  print int(a)
>  
>  Description
>  
>     The  int-function  returns  only the digits before the comma; int(2.5)
>     returns 2 and int(-2.3) returns -2.
>  
>  Example
>  
>  input "Please enter a whole number between 1 and 10: " a
>  if (a=int(a) and a>=1 and a<=10) then
>    print "Thanx !"
>  else
>    print "Never mind ..."
>  endif
>            
>  
>  See also
>  
>     frac
>  
>  L
>  
>     Table of Contents
>  
>     label - mark a specific location within your program for goto, gosub
>            or restore
>  
>     left$() - return (or change) left end of a string
>     len() - return the length of a string
>     line - draw a line
>     line input - read in a whole line of text and assign it to a variable
>     local - mark a variable as local to a subroutine
>     log() - compute the natural logarithm
>     loop - marks the end of an infinite loop
>     lower$() - convert a string to lower case
>     ltrim$() - trim spaces at the left end of a string
>  
>  label
>  
>  Name
>  
>     label -- mark a specific location within your program for goto, gosub
>     or restore
>  
>  Synopsis
>  
>  label foo
>  
>  ...
>  
>  goto foo
>  
>  Description
>  
>     The  label-command  can  be used to give a name to a specific location
>     within  your  program.  Such  a position might be referred from one of
>     three commands: goto, gosub and restore.
>  
>     You may use labels safely within libraries, because a label (e.g. foo)
>     does  not  collide  with  a  label  with the same name within the main
>     program or within another library; yabasic will not mix them up.
>  
>     As  an  aside,  please  note, that line numbers are a special (however
>     deprecated) case of labels; see the second example below.
>  
>  Example
>  
>  for a=1 to 100
>    if (rand(10)>5) goto done
>  next a
>  label done
>  
>  10 for a=1 to 100
>  20   if (rand(10)>5) goto 40
>  30 next a
>  40
>            
>  
>     Within  this  example,  the for-loop will probably be left prematurely
>     with  a goto-statement. This task is done twice: First with labels and
>     then again with line numbers.
>  
>  See also
>  
>     gosub, goto.
>  
>  left$()
>  
>  Name
>  
>     left$() -- return (or change) left end of a string
>  
>  Synopsis
>  
>  print left$(a$,2)
>  left$(b$,3)="foobar"
>  
>  Description
>  
>     The  left$-function  accepts two arguments (a string and a number) and
>     returns  the  part  from  the  left end of the string, whose length is
>     specified  by  its  second argument. Loosely spoken, it simply returns
>     the requested number of chars from the left end of the given string.
>  
>     Note,  that  the left$-function can be assigned to, i.e. it may appear
>     on  the left hand side of an assignment. In this way it is possible to
>     change  a  part  of the variable used within the left$-function. Note,
>     that  that  way  the  length  of  the  string  cannot be changed, i.e.
>     characters  might  be  overwritten,  but not added. For an example see
>     below.
>  
>  Example
>  
>  input "Please answer yes or no: " a$
>  l=len(a$):a$=lower$(a$):print "Your answer is ";
>  if (left$("yes",l)=a$ and l>=1) then
>    print "yes"
>  elsif (left$("no",l)=a$ and l>=1) then
>    print "no"
>  else
>    print "?"
>  endif
>            
>  
>     This example asks a simple yes/no question and goes some way to accept
>     even  incomplete  input,  while  still  beeing  able to reject invalid
>     input.
>  
>     This  second  example  demonstrates  the  capability  to assign to the
>     left$-function.
>  a$="Heiho World !"
>  print a$
>  left$(a$,5)="Hello"
>  print a$
>  
>  See also
>  
>     right$, mid$
>  
>  len()
>  
>  Name
>  
>     len() -- return the length of a string
>  
>  Synopsis
>  
>  x=len(a$)
>  
>  Description
>  
>     The len-function returns the length of its single string argument.
>  
>  Example
>  
>  input "Please enter a password: " a$
>  if (len(a$)<6) error "Password too short !"
>            
>  
>     This  example  checks  the  length  of the password, that the user has
>     entered.
>  
>  See also
>  
>     left$, right$ and mid$,
>  
>  line
>  
>  Name
>  
>     line -- draw a line
>  
>  Synopsis
>  
>  open window 100,100
>  line 0,0,100,100
>  line 0,0 to 100,100
>  new curve
>  line 100,100
>  line to 100,100
>  
>  open window 100,100
>  clear line 0,0,100,100
>  clear line 0,0 to 100,100
>  new curve
>  clear line 100,100
>  clear line to 100,100
>  
>  Description
>  
>     The line-command draws a line. Simple as this is, the line-command has
>     a  large  variety  of  forms as they are listed in the synopsis above.
>     Lets look at them a little closer:
>       * A line has a starting and an end point; therefore the line-command
>         (normally) needs four numbers as arguments, representing these two
>         points. This is the first form appearing within the synopsis.
>       * You  may  seperate  the  two  points  with either ',' or to, which
>         accounts for the second form of the line-command.
>       * The line-command may be used to draw a connected sequence of lines
>         with  a sequence of commands like line x,y; Each command will draw
>         a line from the point where the last line-command left off, to the
>         point  specified  in the arguments. Note, that you need to use the
>         command  new  curve  before you may issue such a line-command. See
>         the example below.
>       * You  may  insert  the  word to for beauty: line to x,y, which does
>         exactly the same as line x,y
>       * Finally,  you may choose not to draw, but to erase the lines; this
>         can  be  done by prepending the phrase clear. This account for all
>         the other forms of the line-command.
>  
>  Example
>  
>  open window 200,200
>  line 10,10 to 10,190
>  line 10,190 to 190,190
>  new curve
>  for a=0 to 360
>    line to 10+a*180/360,100+60*sin(a*pi/180)
>  next a
>            
>  
>     This   example   draws   a  sine-curve  (with  an  offset  in  x-  and
>     y-direction).  Note,  that the first line-command after new curve does
>     not  draw  anything.  Only  the coordinates will be stored. The second
>     iteration  of the loop then uses these coordinates as a starting point
>     for the first line.
>  
>  See also
>  
>     new curve, close curve, open window
>  
>  line input
>  
>  Name
>  
>     line input -- read in a whole line of text and assign it to a variable
>  
>  Synopsis
>  
>  line input a
>  line input a$
>  line input "Hello" a
>  line input #1 a$
>  
>  Description
>  
>     In  most  respects  line input is like the input-command: It reads the
>     new  contents  of  a  variable,  either  from keyboard or from a file.
>     However, line input always reads a complete line and assigns it to its
>     variable.  line input does not stop reading at spaces and is therefore
>     the best way to read in a string which might contain whitespace. Note,
>     that the final newline is stripped of.
>  
>  Example
>  
>  line input "Please enter your name (e.g. Frodo Beutelin): " a$
>  print "Hello ",a$
>            
>  
>     Note  that  the  usage  of  line input is essential in this example; a
>     simple  input-statement  would  only return the string up to the first
>     space, e.g. Frodo.
>  
>  See also
>  
>     input
>  
>  local
>  
>  Name
>  
>     local -- mark a variable as local to a subroutine
>  
>  Synopsis
>  
>  sub foo()
>  
>    local a,b,c$
>  
>    ...
>  
>  end sub 
>  
>  Description
>  
>     The local-command can (and should be) used to mark a variable as local
>     to  the  containing  subroutine.  This means, that a local variable in
>     your  subroutine  is  totally  different from a variable with the same
>     name  within  your  main program. Variables which are known everywhere
>     within your program are called global in contrast.
>  
>     Declaring variables within the subroutine as local helps to avoid hard
>     to  find  bugs;  therefore  local  variables  should  be used whenever
>     possible.
>  
>     Note, that the parameters of your subroutines are always local.
>  
>  Example
>  
>  a=1
>  b=1
>  print a,b
>  foo()
>  print a,b
>  
>  sub foo()
>    local a
>    a=2
>    b=2
>  end sub
>            
>  
>     This  example  demonstrates  the  difference  between local and global
>     variables; it produces this output:
>  
>  1 1
>  1 2
>  
>     As  you  may  see,  the  content of the global variable a is unchanged
>     after  the  subroutine  foo; this is because the assignment a=2 within
>     the  subroutine  affects  the local variable a only and not the global
>     one. However, the variable b is never declared local and therefore the
>     subroutine  changes  the  global  variable,  which is reflected in the
>     output of the second print-statement.
>  
>  See also
>  
>     sub, static
>  
>  log()
>  
>  Name
>  
>     log() -- compute the natural logarithm
>  
>  Synopsis
>  
>  a=log(x)
>  a=log(x,base)
>  
>  Description
>  
>     The  log-function  computes  the  logarithm of its first argument. The
>     optional  second  argument  gives  the base for the logarithm; if this
>     second  argument  is  omitted,  the  euler-constant 2.71828... will be
>     taken as the base.
>  
>  Example
>  
>  open window 200,200
>  for x=10 to 190 step 10:for y=10 to 190 step 10
>    r=3*log(1+x,1+y)
>    if (r>10) r=10
>    if (r<1) r=1
>    fill circle x,y,r
>  next y:next x
>            
>  
>     This draws another nice plot.
>  
>  See also
>  
>     exp
>  
>  loop
>  
>  Name
>  
>     loop -- marks the end of an infinite loop
>  
>  Synopsis
>  
>  do
>    ...
>  loop
>  
>  Description
>  
>     The  loop-command  marks  the ends of a loop (which is started by do),
>     wherein  all  statements within the loop are repeated forever. In this
>     respect  the  do  loop-loop  is  infinite,  however,  you may leave it
>     anytime via break or goto.
>  
>  Example
>  
>  print "Hello, I will throw dice, until I get a 2 ..."
>  do
>    r=int(rand(6))+1
>    print r
>    if (r=2) break
>  loop
>            
>  
>  See also
>  
>     do, for, repeat, while, break
>  
>  lower$()
>  
>  Name
>  
>     lower$() -- convert a string to lower case
>  
>  Synopsis
>  
>  l$=lower$(a$)
>  
>  Description
>  
>     The  lower$-function  accepts a single string-argument and converts it
>     to all lower case.
>  
>  Example
>  
>  input "Please enter a password: " a$
>  if (a$=lower$(a$)) error "Your password is NOT mixed case !"
>            
>  
>     This  example prompts for a password and checks, if it is really lower
>     case.
>  
>  See also
>  
>     upper$
>  
>  ltrim$()
>  
>  Name
>  
>     ltrim$() -- trim spaces at the left end of a string
>  
>  Synopsis
>  
>  a$=ltrim$(b$)
>  
>  Description
>  
>     The  ltrim$-function  removes  all  whitespace  from the left end of a
>     string and returns the result.
>  
>  Example
>  
>  input "Please answer 'yes' or 'no' : " a$
>  a$=lower$(ltrim$(rtrim$(a$)))
>  if (len(a$)>0 and a$=left$("yes",len(a$))) then
>    print "Yes ..."
>  else
>    print "No ..."
>  endif
>            
>  
>     This example prompts for an answer and removes any spaces, which might
>     precede  the  input;  therefore  it  is  even prepared for the (albeit
>     somewhat  patological  case,  that  the  user  first hits space before
>     entering his answer.
>  
>  See also
>  
>     rtrim$, trim$
>  
>  M
>  
>     Table of Contents
>  
>     max() - return the larger of its two arguments
>     mid$() - return (or change) characters from within a string
>     min() - return the smaller of its two arguments
>     mod() - compute the remainder of a division
>     mouseb - extract the state of the mousebuttons from a string returned
>            by inkey$
>  
>     mousemod - return the state of the modifier keys during a mouseclick
>     mousex - return the x-position of a mouseclick
>     mousey - return the y-position of a mouseclick
>  
>  max()
>  
>  Name
>  
>     max() -- return the larger of its two arguments
>  
>  Synopsis
>  
>  print max(a,b)
>  
>  Description
>  
>     Return the maximum of its two arguments.
>  
>  Example
>  
>  dim m(10)
>  for a=1 to 1000
>    m=0
>    For b=1 to 10
>      m=max(m,ran(10))
>    next b
>    m(m)=m(m)+1
>  next a
>  
>  for a=1 to 9
>    print a,": ",m(a)
>  next a
>            
>  
>     Within  the  inner  for-loop  (the  one with the loop-variable b), the
>     example  computes  the  maximum  of  10 random numbers. The outer loop
>     (with  the  loop  variable  a) now repeats this process 1000 times and
>     counts,  how often each maximum appears. The last loop finally reports
>     the result.
>  
>     Now, the interesting question would be, which will be approached, when
>     we  increase the number of iterations from thousend to infinity. Well,
>     maybe someone could just tell me :-)
>  
>  See also
>  
>     min
>  
>  mid$()
>  
>  Name
>  
>     mid$() -- return (or change) characters from within a string
>  
>  Synopsis
>  
>  print mid$(a$,2,1)
>  print mid$(a$,2)
>  mid$(a$,5,3)="foo"
>  mid$(a$,5)="foo"
>  
>  Description
>  
>     The  mid$-function requires three arguments: a string and two numbers,
>     where  the first number specifies a position within the string and the
>     second  one gives the number of characters to be returned; if you omit
>     the  second  argument,  the mid$-function returns all characters up to
>     the end of the string.
>  
>     Note,  that  you may assign to the mid$-function, i.e. mid$ may appear
>     on  the left hand side of an assignment. In this way it is possible to
>     change  a  part  of  the variable used within the mid$-function. Note,
>     that  that  way  the  length  of  the  string  cannot be changed, i.e.
>     characters  might  be  overwritten,  but not added. For an example see
>     below.
>  
>  Example
>  
>  input "Please enter a string: " a$
>  for a=1 to length(a$)
>    if (instr("aeiou",lower$(mid$(a$,a,1)))) mid$(a$,a,1)="e"
>  next a
>  print "When you turn everything to lower case and"
>  print "replace every vowel with 'e', your input reads:"
>  print
>  print a$
>            
>  
>     This   example   transforms   the   input  string  a  bit,  using  the
>     mid$-function  to  retrieve a character from within the string as well
>     as to change it.
>  
>  See also
>  
>     left$ and right$.
>  
>  min()
>  
>  Name
>  
>     min() -- return the smaller of its two arguments
>  
>  Synopsis
>  
>  print min(a,b)
>  
>  Description
>  
>     Return the minimum of its two argument.
>  
>  Example
>  
>  dim m(10)
>  for a=1 to 1000
>    m=min(ran(10),ran(10))
>    m(m)=m(m)+1
>  next a
>  
>  for a=1 to 9
>    print a,": ",m(a)
>  next a
>            
>  
>     For  each  iteration  of  the  loop, the lower of two random number is
>     recorded. The result is printed at the end.
>  
>  See also
>  
>     max
>  
>  mod()
>  
>  Name
>  
>     mod() -- compute the remainder of a division
>  
>  Synopsis
>  
>  print mod(a,b)
>  
>  Description
>  
>     The mod-function divides its two arguments and computes the remainder.
>     Note, that a/b-int(a/b) and mod(a,b) are always equal.
>  
>  Example
>  
>  clear screen
>  print at(10,10) "Please wait ";
>  p$="-\\|/"
>  for a=1 to 100
>    rem  ... do something lengthy here, or simply sleep :-)
>    pause(1)
>    print at(22,10) mid$(p$,1+mod(a,4))
>  next a
>            
>  
>     This  example  executes  some  time consuming action within a loop (in
>     fact, it simply sleeps) and gives the user some indication of progress
>     by displaying a turning bar (that's where the mod()-function comes into
>     play).
>  
>  See also
>  
>     int, frac
>  
>  mouseb
>  
>  Name
>  
>     mouseb -- extract the state of the mousebuttons from a string returned
>     by inkey$
>  
>  Synopsis
>  
>  inkey$
>  print mouseb()
>  print mouseb
>  a$=inkey$
>  print mouseb(a$)
>  
>  Description
>  
>     The  mouseb-function  is  a  helper  function for decoding part of the
>     (rather    complicated)   strings,   which   are   returned   by   the
>     inkey$-function.    If   a   mousebutton   has   been   pressed,   the
>     mouseb-function returns the number (1,2 or 3) of the mousebutton, when
>     it  is  pressed  and  returns  its  negative (-1,-2 or -3), when it is
>     released.
>  
>     The  mouseb-function  accepts zero or one arguments. A single argument
>     should  be  a  string  returned  by  the inkey$-function; if mouseb is
>     called without any arguments, it returns the values from the last call
>     to inkey$, which are stored implicitly and internally by yabasic.
>  
>  Note
>  
>     Note  however, that the value returned by the mouseb-function does not
>     reflect  the current state of the mousebuttons. It rather extracts the
>     information  from  the  string passed as an argument (or from the last
>     call  to  the inkey$-function, if no argument is passed). So the value
>     returned  by mouseb reflects the state of the mousebuttons at the time
>     the  inkey$-function  has  been  called;  as  opposed  to the time the
>     mouseb-function is called.
>  
>  Example
>  
>  open window 200,200
>  clear screen
>  print "Please draw lines; press (and keep it pressed)" 
>  print "the left mousebutton for the starting point,"
>  print "release it for the end-point."
>  do
>    if (mouseb(release$)=1) press$=release$
>    release$=inkey$
>    if (mouseb(release$)=-1) then
>      line mousex(press$),mousey(press$) to mousex(release$),mousey(release$)
>    endif
>  loop
>            
>  
>     This  is  a  maybe  the most simplistic line-drawing program possible,
>     catching presses as well as releases of the first mousebutton.
>  
>  See also
>  
>     inkey$, mousex, mousey and mousemod
>  
>  mousemod
>  
>  Name
>  
>     mousemod -- return the state of the modifier keys during a mouseclick
>  
>  Synopsis
>  
>  inkey$
>  print mousemod()
>  print mousemod
>  a$=inkey$
>  print mousemod(a$)
>  
>  Description
>  
>     The  mousemod-function  is  a helper function for decoding part of the
>     (rather    complicated)   strings,   which   are   returned   by   the
>     inkey$-function  if  a  mousebutton  has  been pressed. It returns the
>     state of the keyboard modifiers (shift, ctrl or alt): If the shift-key
>     is pressed, mousemod returns 1, for the alt-key 2 and for the ctrl-key
>     4.  If  more  than  one  key  is  pressed,  the sum of these values is
>     returned,  e.g.  mousemod  returns  5,  if  shift and ctrl are pressed
>     simultanously.
>  
>     The mousemod-function accepts zero or one arguments. A single argument
>     should  be  a  string  returned by the inkey$-function; if mousemod is
>     called without any arguments, it returns the values from the last call
>     to inkey$ (which are stored implicitly and internally by yabasic).
>  
>  Note
>  
>     Please see also the Note within the mouseb-function.
>  
>  Example
>  
>  open window 200,200
>  clear screen
>  do
>    a$=inkey$
>    if (left$(a$,2)="MB") then
>      x=mousex(a$)
>      y=mousey(a$)
>      if (mousemod(a$)=0) then
>        circle x,y,20
>      else
>        fill circle x,y,20
>      endif
>    endif
>  loop
>            
>  
>     This  program  draws  a circle, whenever a mousebutton is pressed; the
>     circles are filled, when any modifier is pressed, and empty if not.
>  
>  See also
>  
>     inkey$, mousex, mousey and mouseb
>  
>  mousex
>  
>  Name
>  
>     mousex -- return the x-position of a mouseclick
>  
>  Synopsis
>  
>  inkey$
>  print mousex()
>  print mousex
>  a$=inkey$
>  print mousex(a$)
>  
>  Description
>  
>     The  mousex-function  is  a  helper  function for decoding part of the
>     (rather    complicated)   strings,   which   are   returned   by   the
>     inkey$-function;  It  returns  the  x-position of the mouse as encoded
>     within its argument.
>  
>     The  mousex-function  accepts zero or one arguments. A single argument
>     should  be  a  string  returned  by  the inkey$-function; if mousex is
>     called without any arguments, it returns the values from the last call
>     to inkey$ (which are stored implicitly and internally by yabasic).
>  
>  Note
>  
>     Please see also the Note within the mouseb-function.
>  
>  Example
>  
>  open window 200,200
>  clear screen
>  do
>    a$=inkey$
>    if (left$(a$,2)="MB") then
>      line mousex,0 to mousex,200
>    endif
>  loop
>            
>  
>     This   example  draws  vertical  lines  at  the  position,  where  the
>     mousebutton has been pressed.
>  
>  See also
>  
>     inkey$, mousemod, mousey and mouseb
>  
>  mousey
>  
>  Name
>  
>     mousey -- return the y-position of a mouseclick
>  
>  Synopsis
>  
>  inkey$
>  print mousey()
>  print mousey
>  a$=inkey$
>  print mousey(a$)
>  
>  Description
>  
>     The  mousey-function  is  a  helper  function for decoding part of the
>     (rather    complicated)   strings,   which   are   returned   by   the
>     inkey$-function. mousey returns the y-position of the mouse as encoded
>     within its argument.
>  
>     The  mousey-function  accepts zero or one arguments. A single argument
>     should  be  a  string  returned  by  the inkey$-function; if mousey is
>     called without any arguments, it returns the values from the last call
>     to inkey$ (which are stored implicitly and internally by yabasic).
>  
>  Note
>  
>     Please see also the Note within the mouseb-function.
>  
>  Example
>  
>  open window 200,200
>  clear screen
>  do
>    a$=inkey$
>    if (left$(a$,2)="MB") then
>      line 0,mousey to 200,mousey
>    endif
>  loop
>            
>  
>     This  example  draws  horizontal  lines  at  the  position,  where the
>     mousebutton has been pressed.
>  
>  See also
>  
>     inkey$, mousemod, mousex and mouseb
>  
>  N
>  
>     Table of Contents
>  
>     new curve - start a new curve, that will be drawn with the
>            line-command
>  
>     next - mark the end of a for loop
>     not - negate an expression; can be written as !
>     numparams - return the number of parameters, that have been passed to
>            a subroutine
>  
>  new curve
>  
>  Name
>  
>     new  curve --  start  a  new  curve,  that  will  be  drawn  with the
>     line-command
>  
>  Synopsis
>  
>  new curve
>  line to x,y
>  
>  Description
>  
>     The  new  curve-function  starts a new sequence of lines, that will be
>     drawn by repeated line to-commands.
>  
>  Example
>  
>  open window 200,200
>  ellipse(100,50,30,60)
>  ellipse(150,100,60,30)
>  sub ellipse(x,y,xr,yr)
>    new curve
>    for a=0 to 2*pi step 0.2
>      line to x+xr*cos(a),y+yr*sin(a)
>    next a
>    close curve
>  end sub
>    
>            
>  
>     This  example  defines  a  subroutine  ellipse  that draws an ellipse.
>     Within  this  subroutine,  the ellipse is drawn as a sequence of lines
>     started with the new curve command and closed with close curve.
>  
>  See also
>  
>     line, close curve
>  
>  next
>  
>  Name
>  
>     next -- mark the end of a for loop
>  
>  Synopsis
>  
>  for a=1 to 10
>  next a
>  
>  Description
>  
>     The next-keyword marks the end of a for-loop. All statements up to the
>     next-keyword  will be repeated as specified with the for-clause. Note,
>     that  the  name  of the variable is optional; so instead of next a you
>     may write next.
>  
>  Example
>  
>  for a=1 to 300000
>    for b=1 to 21+20*sin(pi*a/20)
>      print "*";
>    next b
>    print
>    sleep 0.1
>  next a
>            
>  
>     This example simply plots a sine-curve until you fall asleep.
>  
>  See also
>  
>     for
>  
>  not
>  
>  Name
>  
>     not -- negate an expression; can be written as !
>  
>  Synopsis
>  
>  if (not a<b) then ...
>  bad=!okay
>  
>  Description
>  
>     The  keyword  not  (or  !  for short) is mostly used within conditions
>     (e.g.  within if- or while-statements). There it is employed to negate
>     the condition or expression (i.e. turn TRUE into FALSE and vice versa)
>  
>     However  not  can  be used within arithmetic calculations too., simply
>     because   there  is  no  difference  between  arithmetic  and  logical
>     expressions.
>  
>  Example
>  
>  input "Please enter three ascending numbers: " a,b,c
>  if (not (a<b and b<c)) error " the numbers you have entered are not ascending .
>  .."
>            
>  
>  See also
>  
>     and,or
>  
>  numparams
>  
>  Name
>  
>     numparams -- return the number of parameters, that have been passed to
>     a subroutine
>  
>  Synopsis
>  
>  sub foo(a,b,c)
>    if (numparams=1) ...
>    ...
>  end sub
>  
>  Description
>  
>     Within  a subroutine the local variable numparam or numparams contains
>     the  number  of  parameters,  that have been passed to the subroutine.
>     This  information  can be useful, because the subroutine may have been
>     called  with  fewer  parameters  than actually declared. The number of
>     values  that  actually  have been passed while calling the subroutine,
>     can be found in numparams.
>  
>     Note,  that arguments which are used in the definition of a subroutine
>     but  are  left  out during a call to it (thereby reducing the value of
>     numparams) receive a value of 0 or "" (empty string) respectively.
>  
>  Example
>  
>  a$="123456789"
>  print part$(a$,4)
>  print part$(a$,3,7)
>  
>  sub part$(a$,f,t)
>    if (numparams=2) then
>      return mid$(a$,f)
>    else 
>      return mid$(a$,f,t-f+1)
>    end if
>  end sub
>            
>  
>     When you run this example, it will print 456789 and 34567. Take a look
>     at  the  subroutine  part$, which returns part of the string which has
>     been  passed  as  an argument. If (besides the string) two numbers are
>     passed,  they  define  the starting and end position of the substring,
>     that will be returned. However, if only one number is passed, the rest
>     of  the  string, starting from this position will be returned. Each of
>     these cases is recognized with the help of the numparams variable.
>  
>  See also
>  
>     sub
>  
>  O
>  
>     Table of Contents
>  
>     on gosub - jump to one of multiple gosub-targets
>     on goto - jump to one of many goto-targets
>     on interrupt - change reaction on keyboard interrupts
>     open - open a file
>     open printer - open printer for printing graphics
>     open window - open a graphic window
>     logical or - logical or, used in conditions
>     or() - arithmetic or, used for bit-operations
>  
>  on gosub
>  
>  Name
>  
>     on goto -- jump to one of multiple gosub-targets
>  
>  Synopsis
>  
>  on a gosub foo,bar,baz
>    ...
>  label foo
>    ...
>  return
>  
>  label bar
>    ...
>  return
>  
>  label baz
>    ...
>  return
>  
>  Description
>  
>     The  on  gosub statement uses its numeric argument (the one between on
>     and gosub) to select an element from the list of labels, which follows
>     after  the gosub-keyword: If the number is 1, the program does a gosub
>     to  the  first label; if the number is 2, to the second and, so on. if
>     the  number  is zero or less, the program continues at the position of
>     the  first  label;  if  the  number  is larger than the total count of
>     labels,  the  execution  continues  at the position of the last label;
>     i.e.  the  first  and  last  label in the list constitute some kind of
>     fallback-slot.
>  
>     Note,  that  the on gosub-command can no longer be considered state of
>     the art; people (not me !) may even start to mock you, if you use it.
>  
>  Example
>  
>  do
>    print "Please enter a number between 1 and 3: "
>    print
>    input "Your choice " a
>    on a gosub bad,one,two,three,bad
>  loop
>  
>  label bad
>    print "No. Please between 1 and 3"
>  return
>  
>  label one
>    print "one"
>  return
>  
>  label two
>    print "two"
>  return
>  
>  label three
>    print "three"
>  return
>            
>  
>     Note,  how  invalid  input (a number less than 1, or larger than 3) is
>     automatically detected.
>  
>  See also
>  
>     goto, on gosub/function>
>  
>  on goto
>  
>  Name
>  
>     on goto -- jump to one of many goto-targets
>  
>  Synopsis
>  
>  on a goto foo,bar,baz
>    ...
>  label foo
>    ...
>  label bar
>    ...
>  label baz
>    ...
>  
>  Description
>  
>     The  on  goto  statement uses its numeric argument (the one between on
>     and  goto  to select an element from the list of labels, which follows
>     after the goto-keyword: If the number is 1, the execution continues at
>     the  first label; if the number is 2, at the second, and so on. if the
>     number  is  zero or less, the program continues at the position of the
>     first  label;  if the number is larger than the total count of labels,
>     the  execution  continues  at the position of the last label; i.e. the
>     first   and   last   label   in  the  list  constitute  some  kind  of
>     fallback-slot.
>  
>     Note, that (unlike the goto-command) the on goto-command can no longer
>     be  considered  state  of the art; people may (not me !) even start to
>     mock you, if you use it.
>  
>  Example
>  
>  label over
>  print "Please Select one of these choices: "
>  print
>  print "  1 -- show time"
>  print "  2 -- show date"
>  print "  3 -- exit"
>  print
>  input "Your choice " a
>  on a goto over,show_time,show_date,terminate,over
>  
>  label show_time
>    print time$()
>  goto over
>  
>  label show_date
>    print date$()
>  goto over
>  
>  label terminate
>  exit
>            
>  
>     Note,  how  invalid  input (a number less than 1, or larger than 3) is
>     automatically  detected;  in such a case the question is simply issued
>     again.
>  
>  See also
>  
>     goto, on gosub/function>
>  
>  on interrupt
>  
>  Name
>  
>     on interrupt -- change reaction on keyboard interrupts
>  
>  Synopsis
>  
>  on interrupt break
>  ...
>  on interrupt continue
>  
>  Description
>  
>     With  the  on  interrupt-command  you  may change the way, how yabasic
>     reacts on a keyboard interrupt; it comes in two variants: on interrupt
>     break  and on interrupt continue. A keyboard interrupt is produced, if
>     you  press  ctrl-C on your keyboard; normally (and certainly after you
>     have  called on interrupt break), yabasic will terminate with an error
>     message.  However  after  the  command  on  interrupt continue yabasic
>     ignores any keyboard interrupt. This may be useful, if you do not want
>     your  program  beeing interruptible during certain critical operations
>     (e.g. updating of files).
>  
>  Example
>  
>  print "Please stand by while writing a file with random data ..."
>  on interrupt continue
>  open "random.data" for writing as #1
>  for a=1 to 100
>    print #1 ran(100)
>    print a," percent done."
>    sleep 1
>  next a
>  close #1
>  on interrupt continue
>            
>  
>     This  program  writes a file with 100 random numbers. The on interrupt
>     continue command insures, that the program will not be terminated on a
>     keyboard  interrupt and the file will be written entirely in any case.
>     The sleep-command just stretches the process arificially to give you a
>     chance to try a ctrl-C.
>  
>  See also
>  
>     There is no related command.
>  
>  open
>  
>  Name
>  
>     open -- open a file
>  
>  Synopsis
>  
>  open a,"file","r"
>  open #a,"file","w"
>  open #a,printer
>  open "file" for reading as a
>  open "file" for writing as #a
>  a=open("file")
>  a=open("file","r")
>  if (open(a,"file")) ...
>  if (open(a,"file","w")) ...
>  
>  Description
>  
>     The  open-command opens a file for reading or writing or a printer for
>     printing text. open comes in a wide variety of ways; it requires these
>     arguments:
>  
>     filenumber
>            In  the  synopsis  this  is  a  or  #a. In yabasic each file is
>            associated  with  a number between 1 and a maximum value, which
>            depends  on  the  operating  system. For historical reasons the
>            filenumber  can  be  preceded  by  a  hash  ('#').  Note,  that
>            specifying  a  filenumber  is  optional;  if it is omitted, the
>            open-function  will  return  a filenumber, which should then be
>            stored  in  a variable for later reference. This filenumber can
>            be   a   simple  number  or  an  arbitrary  complex  arithmetic
>            expression,  in  which  case  braces might be necessary to save
>            yabasic from getting confused.
>  
>     filename
>            In the synopsis above this is "file". This string specifies the
>            name  of  the  file  to  open  (note  the  important  caveat on
>            specifying these filenames).
>  
>     accessmode
>            In  the  synopsis this is "r", "w", for reading or for writing.
>            This  string  or clause specifies the mode in which the file is
>            opened; it may be one of:
>  
>          "r"
>                  Open  the  file  for  reading (may also be written as for
>                  reading).  If  the  file does not exist, the command will
>                  fail.  This  mode  is  the  default,  i.e.  if no mode is
>                  specified  with the open-command, the file will be opened
>                  with this mode.
>  
>          "w"
>                  Open  the  file  for  writing (may also be written as for
>                  writing). If the file does not exist, it will be created.
>  
>          "a"
>                  Open  the  file for appending, i.e. what you write to the
>                  file  will be appended after its initial contents. If the
>                  file does not exist, it will be created.
>  
>          "b"
>                  This  letter  may  not  appear alone, but may be combined
>                  with  the  other  letters  (e.g.  "rb") to open a file in
>                  binary mode (as opposed to text mode).
>  
>     As  you  may  see  from  the  synopsis, the open-command may either be
>     called  as  a command (without braces) or as a function (with braces).
>     If  called as a function, it will return the filenumber or zero if the
>     operation  fails.  Therefore  the open-function may be used within the
>     condition of an if-statement.
>  
>     If  the  open-command fails, you may use peek("error") to retrieve the
>     exact nature of the error.
>  
>     Furthermore  note,  that  there is another, somewhat separate usage of
>     the  open-command;  if  you  specify the bareword printer instead of a
>     filename,  the  command  opens a printer for printing text. Every text
>     (and  only  text)  you print to this file will appear on your printer.
>     Note,  that  this  is very different from printing graphics, as can be
>     done with open printer.
>  
>     Finally  you may read the description for peek("error") to learn which
>     errors may have happened during an open-call.
>  
>  Example
>  
>  open "foo.bar" for writing as #1
>  print #1 "Hallo !"
>  close #1
>  if (not open(1,"foo.bar")) error "Could not open 'foo.bar' for reading"
>  while(not eof(1)) 
>    line input #1 a$
>    print a$
>  wend
>            
>  
>     This  example  simply  opens  the  file foo.bar, writes a single line,
>     reopens it and reads its contents again.
>  
>  See also
>  
>     close, print, peek, peek("error") and open printer
>  
>  open printer
>  
>  Name
>  
>     open printer -- open printer for printing graphics
>  
>  Synopsis
>  
>  open printer
>  open printer "file"
>  
>  Description
>  
>     The  open  printer-command  opens a printer for printing graphics. The
>     command  requires,  that  a  graphic  window  has  been opened before.
>     Everything  that  is  drawn  into this window will then be sent to the
>     printer too.
>  
>     A new piece of paper may be started with the clear window-command; the
>     final (or only) page will appear after the close printer-command.
>  
>     Note,  that you may specify a filename with open printer; in that case
>     the  printout  will  be  sent to a filename instead to a printer. Your
>     program  or  the user will be responsible for sending this file to the
>     printer afterwards.
>  
>     If  you  use  yabasic  under  Unix, you will need a postscript printer
>     (because  yabasic  produces  postscript output). Alternatively you may
>     use  ghostscript to transfrom the postscript file into a form suitable
>     for your printer; but that is beyond the responsibility of yabasic.
>  
>  Example
>  
>  open window 200,200
>  open printer
>  line 0,0 to 200,200
>  text 100,100,"Hallo"
>  close window
>  close printer
>            
>  
>     This  example  will  open  a  window,  draw a line and print some text
>     within; everything will appear on your printer too.
>  
>  See also
>  
>     close printer
>  
>  open window
>  
>  Name
>  
>     open window -- open a graphic window
>  
>  Synopsis
>  
>  open window x,y
>  open window x,y,"font"
>  
>  Description
>  
>     The open window-command opens a window of the specified size. Only one
>     window can be opened at any given moment of time.
>  
>     An  optional  third  argument specifies a font to be used for any text
>     within  the  window.  Please  note,  that if you open a window several
>     times  with  varying  font-arguments,  only  the  first  one will take
>     effect, all others will be ignored; that means that you may onle use a
>     single font for all windows in your program.
>  
>  Example
>  
>  for a=200 to 400 step 10
>    open window a,a
>    for b=0 to a
>      line 0,b to a,b
>      line b,0 to b,a
>    sleep 0.1
>    close window
>  next a
>            
>  
>  See also
>  
>     close window, text
>  
>  logical or
>  
>  Name
>  
>     or -- logical or, used in conditions
>  
>  Synopsis
>  
>  if (a or b) ...
>  while (a or b) ...
>  
>  Description
>  
>     Used  in  conditions (e.g within if or while) to join two expressions.
>     Returns  true,  if  either its left or its right or both arguments are
>     true; returns false otherwise.
>  
>  Example
>  
>  input "Please enter a number"
>  if (a>9 or a<1) print "a is not between 1 and 9"
>            
>  
>  See also
>  
>     and,not
>  
>  or()
>  
>  Name
>  
>     or() -- arithmetic or, used for bit-operations
>  
>  Synopsis
>  
>  x=or(a,b)
>  
>  Description
>  
>     Used  to  compute  the bitwise or of both its argument. Both arguments
>     are treated as binary numbers (i.e. a series of 0 and 1); a bit of the
>     resulting  value will then be 1, if any of its arguments has 1 at this
>     position in their binary representation.
>  
>     Note, that both arguments are silently converted to integer values and
>     that  negative  numbers  have  their own binary representation and may
>     lead to unexpected results when passed to or.
>  
>  Example
>  
>  print or(14,3)
>            
>  
>     This will print 15. This result is clear, if you note, that the binary
>     representation  of  14 and 3 are 1110 and 0011 respectively; this will
>     yield 1111 in binary representaion or 15 as decimal.
>  
>  See also
>  
>     oand, eor and not
>  
>  P
>  
>     Table of Contents
>  
>     pause - pause, sleep, wait for the specified number of seconds
>     peek - retrieve various internal information
>     peek$ - retrieve various internal string-information
>     pi - a constant with the value 3.14159
>     poke - change selected internals of yabasic
>     print - Write to terminal or file
>     putbit - draw a rectangle of pixels into the graphic window
>     putscreen - draw a rectangle of characters into the text terminal
>  
>  pause
>  
>  Name
>  
>     pause -- pause, sleep, wait for the specified number of seconds
>  
>  Synopsis
>  
>  pause 5
>  
>  Description
>  
>     The pause-command has many different names: You may write pause, sleep
>     or  wait  interchangeably;  whatever you write, yabasic will always do
>     exactly the same.
>  
>     The  pause-command  will  simply  wait  for  the  specified  number of
>     seconds.  This  may  be a fractional number, so you may well wait less
>     than  a second. However, if you try to pause for a smaller and smaller
>     interval (e.g. 0.1 seconds, 0.01 seconds, 0.001 seconds and so on) you
>     will find that at some point yabasic will not wait at all. The minimal
>     interval  that can be waited depends on the system (Unix, Windows) you
>     are using.
>  
>     The  pause-command  cannot  be interrupted. However, sometimes you may
>     want  the  wait  to  be  interuptible  by simply pressing a key on the
>     keyboard. In such cases you should consider using the inkey$-function,
>     with a number of seconds as an argument).
>  
>  Example
>  
>  deg=0
>  do
>    maxx=44+40*sin(deg)
>    for x=1 to maxx
>      print "*";
>    next x
>    pause 0.1+(maxx*maxx/(4*84*84))
>    print
>    deg=deg+0.1
>  loop
>            
>  
>     This  example draws a sine-curve; due to the pause-statement the speed
>     of  drawing  varies in the same way as the speed of a ball might vary,
>     if it would roll along this curve under the influence of gravity.
>  
>  See also
>  
>     sleep, wait
>  
>  peek
>  
>  Name
>  
>     peek -- retrieve various internal information
>  
>  Synopsis
>  
>  print peek("foo")
>  a=peek(#1)
>  
>  Description
>  
>     The  peek-function has many different and mostly unrelated uses. It is
>     a  kind  of grabbag for retrieving all kinds of numerical information,
>     internal  to  yabasic.  The  meaning  of  the  numbers returned be the
>     peek-function depends on the string or number passed as an argument.
>  
>     peek   always   returns   a   number,   however  the  closely  related
>     peek$-function   exists,   which   may  be  used  to  retrieve  string
>     information  from  among  the internals of yabasic. Finally note, that
>     some  of the values which are retrieved with peek may even be changed,
>     using the poke-function.
>  
>     There  are  two variants of the peek-function: One expects an integer,
>     positive  number  and  is described within the first entry of the list
>     below.  The other variant expects one of a well defined set of strings
>     as  described  in the second and all the following entries of the list
>     below.
>  
>     peek(a), peek(#a)
>            Read  a single character from the file a (which must be open of
>            course).
>  
>     peek("winheight")
>            Return  the  height of the graphic-window in pixels. If none is
>            open,  this  peek  will  return  the  height of the last window
>            opened or 100, if none has been opened yet.
>  
>     peek("winwidth")
>            Return  the  width  of the graphic-window in pixels. If none is
>            open, this peek will return the width of the last window opened
>            or 100, if none has been opened yet.
>  
>     peek("fontheight")
>            Return  the  height of the font used within the graphic window.
>            If  none  is open, this peek will return the height of the last
>            font used or 10, if no window has been opened yet.
>  
>     peek("screenheight")
>            Return  the height in characters of the window, wherein yabasic
>            runs.  If  you  have not called clear screen yet, this peekwill
>            return 0, regardless of the size of your terminal.
>  
>     peek("screenwidth")
>            Return  the  width in characters of the window, wherein yabasic
>            runs.  If  you  have not called clear screen yet, this peekwill
>            return 0, regardless of the size of your terminal.
>  
>     peek("argument")
>            Return  the  number  of  arguments,  that  have  been passed to
>            yabasic  at  invocation  time.  E.g. if yabasic has been called
>            like  this: yabasic foo.yab bar baz, then peek("argument") will
>            return 2. This is because foo.yab is treated as the name of the
>            program to run, whereas bar and baz are considered arguments to
>            the  program,  which  are passed on the commandline. Note, that
>            for windows-users, who tend to click on the icon (as opposed to
>            starting  yabasic  on  the  command line), this peekwill mostly
>            return 0.
>  
>            The    function    peek("argument")    can    be   written   as
>            peek("arguments") too.
>  
>            You   will   want  to  check  out  the  corresponding  function
>            peek$("argument")  to  actually  retrieve  the arguments. Note,
>            that each call to peek$("argument") reduces the number returned
>            by peek("argument").
>  
>     peek("version")
>            Return the version number of yabasic (e.g. 2.72).
>  
>     peek("error")
>            Return  a  number specifying the nature of the last error in an
>            open-   or   seek-statement.   Normally   an  error  within  an
>            open-statement  immediately  terminates  your  program  with an
>            appropriate error-message, so there is no chance and no need to
>            learn  more  about the nature of the error. However, if you use
>            open  as a condition (e.g. if (open(#1,"foo")) ...) the outcome
>            (success  or  failure) of the open-operation will determine, if
>            the  condition  evaluates  to  true  or  false.  If now such an
>            operation  fails,  your  program will not be terminated and you
>            might want to learn the reason for failure. This reason will be
>            returned  by  peek("error")  (as a number) or by peek$("error")
>            (as a string)
>  
>            The  table  below  shows  the  various  error  codes; the value
>            returned  by  peek$("error")  explains the nature of the error.
>            Note, that the codes 10,11 and 12 refer to the seek-command.
>  
>            Table 5.1. Error codes
>  
>     peek("error") peek$("error") Explanation
>     2 Stream already in use Do not try to open one and the same filenumber
>     twice; rather close it first.
>     3  'x'  is  not a valid filemode The optional filemode argument, which
>     may be passed to the open-function, has an invalid value
>     4  could  not  open  'foo'  The  open-call  did  not  work, no further
>     explanation is available.
>     5 reached maximum number of open files You have opened more files than
>     your operating system permits.
>     6  cannot  open  printer:  already printing graphics The commands open
>     printer  and  open  #1,printer  both  open  a  printer (refer to their
>     description  for the difference). However, only one can be active at a
>     time;  if  you  try to do both at the same time, you will receive this
>     error.
>     7 could not open line printer Well, it simply did not work.
>     9  invalid  stream number An attempt to use an invalid (e.g. negative)
>     stream number; example: open(-1,"foo")
>     10 could not position stream x to byte y seek did not work.
>     11  stream x not open You have tried to seek within a stream, that has
>     not been opened yet.
>     12  seek  mode  'x'  is none of begin,end,here The argument, which has
>     been passed to seek is invalid.
>  
>  Example
>  
>  open "foo" for reading as #1
>  open "bar" for writing as #2
>  while(not eof(#1))
>    poke #2,chr$(peek(#1));
>  wend
>            
>  
>     This program will copy the file foo byte by byte to bar.
>  
>     Note,  that  each peek does something entirely different, and only one
>     has  been  demonstrated  above. Therefore you need to make up examples
>     yourself for all the other peeks.
>  
>  See also
>  
>     peek$, poke, open
>  
>  peek$
>  
>  Name
>  
>     peek$ -- retrieve various internal string-information
>  
>  Synopsis
>  
>  print peek$("foo")
>  
>  Description
>  
>     The peek$-function has many different and unrelated uses. It is a kind
>     of grabbag for retrieving all kinds of string information, internal to
>     yabasic;   the   exact   nature   of   the  strings  returned  be  the
>     peek$-function depends on the string passed as an argument.
>  
>     peek$   always   returns   a   string,  however  the  closely  related
>     peek-function   exists,  which  may  be  used  to  retrieve  numerical
>     information  from  among  the internals of yabasic. Finally note, that
>     some of the values which are retrieved with peek$ may even be changed,
>     using the poke-function.
>  
>     The following list shows all possible arguments to peek$:
>  
>     peek$("infolevel")
>            Returns  either "debug", "note", "warning", "error" or "fatal",
>            depending on the current infolevel. This value can be specified
>            with   an   option  (either  under  windows  or  unix)  on  the
>            commandline or changed during the execution of the program with
>            the  corresponding  poke;  however, normally only the author of
>            yabasic (me !) would want to change this from its default value
>            "warning".
>  
>     peek$("textalign")
>            Returns  one  of  nine possible strings, specifying the default
>            alignment    of    text   within   the   graphics-window.   The
>            alignment-string  returned  by  this  peek  describes,  how the
>            text-command  aligns  its  string-argument  with respect to the
>            coordinates  supplied.  However,  this value does not apply, if
>            the  text-command  explicitly  specifies  an alignment. Each of
>            these  strings  is  two  characters  long.  The first character
>            specifies the horizontal alignment and can be either l, r or c,
>            which  stand  for  left,  right or center. The second character
>            specifies  the  vertical alignment and can be one of t, b or c,
>            which stand for top, bottom or center respectively.
>  
>            You  may  change this value with the corresponding command poke
>            "textalign",...;  the  initial value is lb, which means the top
>            of  the  left and the top edge if the text will be aligned with
>            the coordinates, that are specified within the text-command.
>  
>     peek$("windoworigin")
>            This  peek  returns a two character string, which specifies the
>            position  of the origin of the coordinate system of the window;
>            this  string  might  be  changed with the corresponding command
>            poke  "windoworigin",x,y  or  specified  as the argument of the
>            origin  command;  see  there  for a detailed description of the
>            string, which might be returned by this peek.
>  
>     peek$("error")
>            Return  a  string describing the nature of the last error in an
>            open-  or  seek-statement.  See the corresponding peek("error")
>            for a detailed description.
>  
>     peek$("library")
>            Return the name of the library, this statement is contained in.
>            See  the  import-command for a detailed description or for more
>            about libraries.
>  
>     peek$("os")
>            This  peek returns the name of the operating system, where your
>            program executes. This can be either windows or unix.
>  
>     peek$("font")
>            Return  the name of the font, which is used for text within the
>            graphic  window;  this  value  can  be  specified  as the third
>            argument to the open window-command.
>  
>     peek$("argument")
>            Return  one  of the arguments, that have been passed to yabasic
>            at  invocation  time  (the next call will return the the second
>            argument,  and  so  on).  E.g.  if yabasic has been called like
>            this:   yabasic  foo.yab  bar  baz,  then  the  first  call  to
>            peek$("argument")  will  return bar. This is because foo.yab is
>            treated  as the name of the program to run, whereas bar and baz
>            are  considered  arguments to this program, which are passed on
>            the  commandline.  The  second  call  to peek$("argument") will
>            return  baz. Note, that for windows-users, who tend to click on
>            the  icon (as opposed to starting yabasic on the command line),
>            this peekwill mostly return the empty string.
>  
>            Note,    that    peek$("argument")    can    be    written   as
>            peek$("arguments").
>  
>            Finally  you  will want to check out the corresponding function
>            peek("argument").
>  
>  Example
>  
>  print "You have supplied these arguments: "
>  while(peek("argument"))
>    print peek("argument"),peek$("argument")
>  wend
>            
>  
>     If  you save this program in a file foo.yab and execute it via yabasic
>     t.yab  a b c (for windows users: please use the commandline for this),
>     your will get this output:
>  3a
>  2b
>  1c
>  
>  See also
>  
>     peek, poke, open
>  
>  pi
>  
>  Name
>  
>     pi -- a constant with the value 3.14159
>  
>  Synopsis
>  
>  print pi
>  
>  Description
>  
>     pi  is 3.14159265359 (well at least for yabasic); do not try to assign
>     to  pi  (e.g.  pi=22/7) this would not only be mathematically dubious,
>     but would also result in a syntax error.
>  
>  Example
>  
>  for a=0 to 180
>    print "The sine of ",a," degrees is ",sin(a*pi/180)
>  next a
>            
>  
>     This program uses pi to transform an angle from degrees into radians.
>  
>  See also
>  
>     euler
>  
>  poke
>  
>  Name
>  
>     poke -- change selected internals of yabasic
>  
>  Synopsis
>  
>  poke "foo","bar"
>  poke "foo",baz
>  poke #a,"bar"
>  poke #a,baz
>  
>  Description
>  
>     The poke-command may be used to change details of yabasic's behaviour.
>     Like  the  related  function  peek,  poke  does many different things,
>     depending on the arguments supplied.
>  
>     Here are the different things you can do with poke:
>  
>     poke "textalign","cc"
>            This poke changes the default alignment of text with respect to
>            the coordinates supplied within the text-command. However, this
>            value  does not apply, if the text-command explicitly specifies
>            an  alignment.  The  second argument ("cc" in the example) must
>            always  be  two characters long; the first character can be one
>            of  l (left), r (right) or c (center); the second character can
>            be   either  t  (top),  b  (bottom)  or  c  (center);  see  the
>            corresponding  peek$("textalign") for a detailed description of
>            this argument.
>  
>     poke "windoworigin","lt"
>            This  poke  moves  the  origin  of the coordinate system of the
>            window  to the specified position. The second argument ("lt" in
>            the  example)  must  always  be  two characters long; the first
>            character  can be one of l (left), r (right) or c (center); the
>            second  character  can  be  either  t  (top),  b  (bottom) or c
>            (center).   Together  those  two  characters  specify  the  new
>            position   of  the  coordinate-origin.  See  the  corresponding
>            peek$("windoworigin")  for  a more in depth description of this
>            argument.
>  
>     poke "infolevel","debug"
>            Change the amount of internal information, that yabasic outputs
>            during execution.
>  
>            The  second  argument can be either "debug", "note", "warning",
>            "error"  or  "fatal".  However,  normally  you will not want to
>            change this from its default value "warning".
>  
>            See also the related peek$("infolevel").
>  
>     poke #1,a
>            Write  the given byte (a in the example above) to the specified
>            stream (#a in the example).
>  
>            See also the related function function peek(#1).
>  
>  Example
>  
>  print "Hello, now you will see, how much work"
>  print "a simple for-loop involves ..."
>  input "Please press return " a$
>  poke "infolevel","debug"
>  for a=1 to 10:next a
>            
>  
>     This  example  only  demonstrates  one  of  the  many pokes, which are
>     described  above:  The  program switches the infolevel to debug, which
>     makes  yabasic  produce  a lot of debug-messages during the subsequent
>     for-loop.
>  
>  See also
>  
>     peek, peek$
>  
>  print
>  
>  Name
>  
>     print -- Write to terminal or file
>  
>  Synopsis
>  
>  print "foo",a$,b
>  print "foo","a$,b;
>  print #a "foo",a$
>  print #a "foo",a$;
>  print a using "##.###"
>  print reverse "foo"
>  print at(10,10) a$,b
>  print @(10,10) a$,b
>  print color("red","blue") a$,b
>  print color("magenta") a$,b
>  print color("green","yellow") at(5,5) a$,b
>  
>  Description
>  
>     The  print-statement  outputs  strings  or  characters, either to your
>     terminal (also known as console) or to an open file.
>  
>     To understand all those uses of the print-statement, let's go throught
>     the various lines in the synopsis above:
>  
>     print "foo",a$,b
>            Print  the  string foo as well as the contents of the variables
>            a$ and b onto the screen, silently adding a newline.
>  
>     print "foo",a$,b;
>            (Note the trailing semicolon !) This statement does the same as
>            the  one  above;  only  the  implicit newline is skipped, which
>            means that the next print-statement will append seamlessly.
>  
>     print #a "foo",a$
>            This  is  the way to write to files. The file with the number a
>            must  be  open  already, an implicit newline is added. Note the
>            file-number #a, which starts with a hash ('#') amd is separated
>            from the rest of the statement by a space only. The file-number
>            (contained  in  the  variable  a)  must have been returned by a
>            previous open-statement (e.g. a=open("bar")).
>  
>     print #a "foo",a$;
>            The same as above, but without the implicit newline.
>  
>     print a using "##.###"
>            Print  the  number  a  with as many digits before and after the
>            decimal  dot  as  given  by  the  number  of '#'-signs. See the
>            entries  for  using and str$ for a detailed description of this
>            format.
>  
>     print reverse "foo"
>            As   all  the  print-variants  to  follow,  this  form  of  the
>            print-statement  can only be issued after clear screen has been
>            called.  The  strings  and numbers after the reverse-clause are
>            simply    printed    inverse    (compared    to    the   normal
>            print-statement).
>  
>     print at(10,10) a$,b
>            Print  at  the  specified  (x,y)-position. This is only allowed
>            after  clear  screen  has  been  called.  You may want to query
>            peek$("screenwidth")  or  peek$("screenheight")  to  learn  the
>            actual size of your screen. You may add a semicolon to suppress
>            the implicit newline.
>  
>     print @(10,10) a$,b
>            This  is  exactly the same as above, however, at may be written
>            as @.
>  
>     print color("red","blue") at(5,5) a$,b
>            Print  with the specified fore- ("red") and background ("blue")
>            color  (or  colour).  The possible values are "black", "white",
>            "red",  "blue",  "green", "yellow", "cyan" or "magenta". Again,
>            you  need to call clear screen first and add a semicolon if you
>            want to suppress the implicit newline.
>  
>     print color("magenta") a$,b
>            You may specify the foreground color only.
>  
>     print color("green","yellow") a$,b
>            A  color  and  a  position (in this sequence, not the other way
>            around) may be specified at once.
>  
>  Example
>  
>  clear screen
>  columns=peek("screenwidth")
>  lines=peek("screenheight")
>  dim col$(7)
>  for a=0 to 7:read col$(a):next a
>  data "black","white","red","blue","green","yellow","cyan","magenta"
>  
>  for a=0 to 2*pi step 0.1
>    print colour(col$(mod(i,8))) at(columns*(0.8*sin(a)+0.9)/2,lines*(0.8*cos(a)+
>  0.9)/2) "*"
>    i=i+1
>  next a
>            
>  
>     This example draws a cloured ellipse within the text window.
>  
>  See also
>  
>     at, color, input, clear screen, using, ;
>  
>  putbit
>  
>  Name
>  
>     putbit -- draw a rectangle of pixels into the graphic window
>  
>  Synopsis
>  
>  open window 200,200
>  ...
>  a$=getbit(20,20,50,50)
>  ...
>  putbit a$,30,30
>  putbit a$ to 30,30
>  putbit a$,30,30,"or"
>  
>  Description
>  
>     The  putbit-command  is the counterpart of the getbit-function. putbit
>     requires  a  string  as returned by the getbit-function. Such a string
>     contains a rectangle from the graphic window; the putbit-function puts
>     such a rectangular region back into the graphic-window.
>  
>     Note,  that  the  putbit-command  currently  accepts a third argument.
>     However  only  the string value "or" is supported here. The effect is,
>     that  only those pixel, which are set in the string will be set in the
>     graphic  window.  Those  pixels, which are not set in the string, will
>     not change in the window (as opposed to beeing cleared).
>  
>     Note,  that  the format of the string returned by this function is due
>     to change as soon as yabasic will learn, how to deal with colors.
>  
>  Example
>  
>  c$="41,41:0000000000000000000000000400000000cff1000000ffff100000ffff700008fffff
>  30008ffffff0008ffffff3008fffffff000fffffff100fffffff700ffffffff10efffffff30cfff
>  ffff70cffffffff18ffffffff30ffffffff70effffffff0cffffffff1cffffffff30ffffffff70e
>  ffffffff0cffffffff18ffffffff30ffffffff70cfffffff708ffffffff00ffffffff10cfffffff
>  100fffffff100effffff3008ffffff3000efffff30008fffff30000cffff100000ffff1000000ff
>  700000000000000000000000000000000000"
>  
>  open window 200,200
>  do
>    x=ran(200)
>    y=ran(200)
>    putbit c$,x,y,"or"
>  loop
>            
>  
>     This  program  uses  a  precanned  string  (containing  the image of a
>     circle) and draws it repeatedly into the graphic-window. The mode "or"
>     ensures, that no pixels will be cleared.
>  
>  See also
>  
>     getbit$, open window
>  
>  putscreen
>  
>  Name
>  
>     putscreen -- draw a rectangle of characters into the text terminal
>  
>  Synopsis
>  
>  clear screen
>  ...
>  a$=getscreen$(5,5,10,10)
>  ...
>  putscreen a$,7,7
>  
>  Description
>  
>     The  putscreen-command  is the counterpart of the getscreen$-function.
>     putscreen  requires  a  string  as returned by the getscreen-function.
>     Such  a  string  contains  a rectangular detail from the terminal; the
>     putscreen-function puts such a region back into the terminal-window.
>  
>     Note, that clear screen must have been called before.
>  
>  Example
>  
>  clear screen
>  for a=1 to 200
>    print color("red") "Hallo !"; 
>    print color("blue") "Welt !";
>  next a
>  r$=getscreen$(0,0,20,20)
>  for x=0 to 60
>    putscreen r$,x,0
>    sleep 0.1
>  next x
>            
>  
>     This example prints the string "Hallo !Welt !" all over the screen and
>     then moves a rectangle from one side to the other.
>  
>  See also
>  
>     getscreen$, clear screen
>  
>  R
>  
>     Table of Contents
>  
>     ran() - return a random number
>     read - read data from data-statements
>     rectangle - draw a rectangle
>     redim - create an array prior to its first use. A synonym for dim
>     rem - start a comment
>     repeat - start a repeat-loop
>     restore - reposition the data-pointer
>     return - return from a subroutine or a gosub
>     reverse - print reverse (background and foreground colors exchanged)
>     right$() - return (or change) the right end of a string
>     rinstr() - find the rightmost occurence of one string within the other
>     rtrim$() - trim spaces at the right end of a string
>  
>  ran()
>  
>  Name
>  
>     ran() -- return a random number
>  
>  Synopsis
>  
>  print ran()
>  x=ran(y)
>  
>  Description
>  
>     The ran-function returns a random number. If no argument is given, the
>     number  returned  is  in  the  range  from  0  to 1; where only 0 is a
>     possible  value; 1 will never be returned. If an argument is supplied,
>     the  number  returned will be in the range from 0 up to this argument,
>     whereas this argument itself is not a possible return value.
>  
>  Example
>  
>  clear screen
>  c=peek("screenwidth")-1
>  l=peek("screenheight")
>  
>  dim col$(8)
>  for a=0 to 7:read col$(a):next a
>  data "black","white","red","blue","green","yellow","cyan","magenta"
>  
>  do
>    x=ran(c)
>    y=l-ran(l*exp(-32*((x/c-1/2)**2)))
>    i=i+1
>    print color(col$(mod(i,8))) at(x,y) "*";
>  loop
>            
>  
>     This example will print a cloured bell-curve.
>  
>  See also
>  
>     int
>  
>  read
>  
>  Name
>  
>     read -- read data from data-statements
>  
>  Synopsis
>  
>  read a$,a
>  ...
>  data "Hello !",7
>  
>  Description
>  
>     The  read-statement  retrieves  literal  data,  which is stored within
>     data-statements elsewhere in your program.
>  
>  Example
>  
>  read num
>  dim col$(num)
>  for a=1 to num:read col$(a):next a
>  clear screen
>  print "These are the colours known to yabasic:\\n"
>  for a=1 to num
>    print colour(col$(a)) col$(a)
>  next a
>  
>  data 8,"black","white","red","blue"
>  data "green","yellow","cyan","magenta"
>            
>  
>     This  program prints the names of the colors known to yabasic in those
>     very colors.
>  
>  See also
>  
>     data, restore
>  
>  rectangle
>  
>  Name
>  
>     rectangle -- draw a rectangle
>  
>  Synopsis
>  
>  open window 100,100
>  rectangle 10,10 to 90,90
>  rectangle 20,20,80,80
>  rect 20,20,80,80
>  box 30,30,70,70
>  clear rectangle 30,30,70,70
>  fill rectangle 40,40,60,60
>  clear fill rectangle 60,60,40,40
>  
>  Description
>  
>     The  rectangle-command  (also known as box or rect, for short) draws a
>     recatangle;  it  accepts  four parameters: The x- and y-coordinates of
>     two  facing  cornerpoints  of the rectangle. With the optional clauses
>     clear  and  fill  (which  may  appear  both  and  in any sequence) the
>     rectangle can be cleared and filled respectively.
>  
>  Example
>  
>  open window 200,200
>  c=1
>  do 
>    for phi=0 to pi step 0.1
>      if (c) then 
>        rectangle 100+100*sin(phi),100+100*cos(phi) to 100-100*sin(phi),100-100*c
>  os(phi)
>      else 
>        clear rectangle 100+100*sin(phi),100+100*cos(phi) to 100-100*sin(phi),100
>  -100*cos(phi)
>      endif
>      sleep 0.1
>    next phi
>    c=not c
>  loop
>            
>  
>     This  example  draws a nice animated pattern; watch it for a couple of
>     hours, to see how it develops.
>  
>  See also
>  
>     open window, open printer, line, circle
>  
>  redim
>  
>  Name
>  
>     redim -- create an array prior to its first use. A synonym for dim
>  
>  Synopsis
>  
>  See the dim-command.
>  
>  Description
>  
>     The redim-command does exactly the same as the dim-command; it is just
>     a  synonym. redim has been around in older versions of basic (not even
>     yabasic)  for  many  years;  therefore  it is supported in yabasic for
>     compatibility reasons.
>  
>     Please refer to the entry for the dim-command for further information.
>  
>  rem
>  
>  Name
>  
>     rem -- start a comment
>  
>  Synopsis
>  
>  rem  Hey, this is a comment
>  #    this is a comment too
>  // even this
>  print "Not a comment" #    This is an error !!
>  print "Not a comment"://   But this is again a valid comment
>  print "Not a comment" //   even this.
>  print "Not a comment" rem  and this !
>  
>  Description
>  
>     rem introduces a comment (like # or //), that extends up to the end of
>     the line.
>  
>     Those  comments  do  not even need a colon (':' infront of them); they
>     (rem,  #  and //) all behave alike except for #, which may only appear
>     at  the  very beginning of a line; therefore the fourth example in the
>     synopsis above (print "Not a comment" # This is an error !!) is indeed
>     an error.
>  
>     Note,  that rem is an abbreviation for remark. remark however is not a
>     valid command in yabasic.
>  
>     Finally  note,  that  a  comment intoduced with '#' may have a special
>     meaning under unix; see the entry for # for details.
>  
>  Example
>  
>  #
>  rem   comments on data structures
>  #     are more useful than
>  //    comments on algorithms.
>  rem
>            
>  
>     This program does nothing, but in a splendid and well commented way.
>  
>  See also
>  
>     #, //
>  
>  repeat
>  
>  Name
>  
>     repeat -- start a repeat-loop
>  
>  Synopsis
>  
>  repeat 
>    ...
>  until (...)
>  
>  Description
>  
>     The   repeat-loop   executes  all  the  statements  up  to  the  final
>     until-keyword  over  and  over.  The  loop  is executed as long as the
>     condition,  which is specified with the until-clause, becomes true. By
>     construction,  the  statements  within  the loop are executed at least
>     once.
>  
>  Example
>  
>  x=0
>  clear screen
>  print "This program will print the numbers from 1 to 10"
>  repeat
>    x=x+1
>    print x
>    print "Press any key for the next number, or 'q' to quit"
>    if (inkey$="q") break
>  until(x=10)
>            
>  
>     This program is pretty much useless, but self-explanatory.
>  
>  See also
>  
>     until, break, while, do
>  
>  restore
>  
>  Name
>  
>     restore -- reposition the data-pointer
>  
>  Synopsis
>  
>  read a,b,c,d,e,f
>  restore
>  read g,h,i
>  restore foo
>  data 1,2,3
>  label foo
>  data 4,5,6
>  
>  Description
>  
>     The   restore-command   may   be   used   to   reset  the  reading  of
>     data-statements,  so  that the next read-statement will read data from
>     the first data-statement.
>  
>     You  may  specify  a label with the restore-command; in that case, the
>     next read-statement will read data starting at the given label. If the
>     label   is   omitted,   reading   data   will  begin  with  the  first
>     data-statement within your program.
>  
>  Example
>  
>  input "Which language (german/english) ? " l$
>  if (instr("german",l$)>0) then
>    restore german
>  else
>    restore english
>  endif
>  
>  for a=1 to 3
>    read x,x$
>    print x,"=",x$
>  next a
>  
>  label english
>  data 1,"one",2,"two",3,"three"
>  label german
>  data 1,"eins",2,"zwei",3,"drei"
>            
>  
>     This  program  asks to select one of those languages known to me (i.e.
>     english  or  german)  and  then prints the numbers 1,2 and 3 and their
>     textual equivalents in the chosen language.
>  
>  See also
>  
>     read, data, label
>  
>  return
>  
>  Name
>  
>     return -- return from a subroutine or a gosub
>  
>  Synopsis
>  
>  gosub foo
>  ...
>  label foo
>  ...
>  return
>  
>  sub bar(baz)
>    ...
>    return quertz
>  end sub
>  
>  Description
>  
>     The  return-statement  serves  two different (albeit somewhat related)
>     purposes.  The  probably  more  important  use  of return is to return
>     control  from  within a subroutine to the place in your program, where
>     the  subroutine  has  been  called.  If  the subroutine is declared to
>     return  a value, the return-statement might be accompanied by a string
>     or number, which constitutes the return value of the subroutine.
>  
>     However,   even   if   the  subroutine  should  return  a  value,  the
>     return-statement  need  not carry a value; in that case the subroutine
>     will  return  0  or  the  empty  string  (depending on the type of the
>     subroutine).  Moreover,  feel free to place multiple return-statements
>     within  your  subroutine;  it's  a nice way of controlling the flow of
>     execution.
>  
>     The  second (but historcially first) use of return is to return to the
>     position,  where  a  prior gosub has left off. In that case return may
>     not carry a value.
>  
>  Example
>  
>  do
>    read a$
>    if (a$="") then
>      print
>      end
>    endif
>    print mark$(a$)," ";
>  loop
>  
>  data "The","quick","brown","fox","jumped"
>  data "over","the","lazy","dog",""
>  
>  sub mark$(a$)
>    if (instr(lower$(a$),"q")) return upper$(a$)
>    return a$
>  end sub
>            
>  
>     This example features a subroutine mark$, that returns its argument in
>     upper  case, if it contains the letter "q", or unchanged otherwise. In
>     the test-text the word quick will end up beeing marked as QUICK.
>  
>     The  example  above demonstrates return within subroutines; please see
>     gosub for an example of how to use return in this context.
>  
>  See also
>  
>     sub, gosub
>  
>  reverse
>  
>  Name
>  
>     reverse -- print reverse (background and foreground colors exchanged)
>  
>  Synopsis
>  
>  clear screen
>  ...
>  print reverse "foo"
>  
>  Description
>  
>     reverse  may  be  used  to  print  text  in  reverse. reverse is not a
>     seperate  command,  but  part of the print-command; it may be included
>     just after the print and can only be issued once that clear screen has
>     been issued.
>  
>  Example
>  
>  clear screen
>  
>  print "1 ";
>  c=3
>  do
>    prim=true
>    for a=2 to sqrt(c)
>      if (frac(c/a)=0) then
>        prim=false
>        break
>      endif
>    next a
>    if (prim) then
>      print
>      print reverse c;
>    else
>      print c;
>    endif
>    print " ";
>    c=c+1
>  loop
>            
>  
>     This  program  prints numbers from 1 on and marks each prime number in
>     reverse.
>  
>  See also
>  
>     at, color, print, clear screen
>  
>  right$()
>  
>  Name
>  
>     right$() -- return (or change) the right end of a string
>  
>  Synopsis
>  
>  print right$(a$,2)
>  right$(b$,2)="baz"
>  
>  Description
>  
>     The right$-function requires two arguments (a string and a number) and
>     returns  the  part  from  the right end of the string, whose length is
>     specified  by  its  second  argument.  So,  right$  simply returns the
>     requested number of chars from the right end of the given string.
>  
>     Note,  that the right$-function can be assigned to, i.e. it may appear
>     on  the left hand side of an assignment. In this way it is possible to
>     change  a  part of the variable used within the right$-function. Note,
>     that  that  way  the  length  of  the  string  cannot be changed, i.e.
>     characters  might  be  overwritten,  but not added. For an example see
>     below.
>  
>  Example
>  
>  print "Please enter a length either in inch or centimeter"
>  print "please add 'in' or 'cm' to mark the unit."
>  input "Length: " a$
>  if (right$(a$,2)="in") then
>     length=val(a$)*2.56
>  elsif (right$(a$,2)="cm") then
>     length=val(a$)
>  else
>     error "Invalid input: "+a$
>  endif
>            
>  
>     This  program  allows  the user to enter a length qulified with a unit
>     (either inch or centimeter).
>  
>     This  second  example  demonstrates  the  capability  to assign to the
>     right$-function.
>  a$="Heiho World !"
>  print a$
>  right$(a$,7)="dwarfs."
>  print a$
>  
>  See also
>  
>     right$ and mid$
>  
>  rinstr()
>  
>  Name
>  
>     rinstr() --  find  the  rightmost  occurence of one string within the
>     other
>  
>  Synopsis
>  
>  pos=rinstr("Thequickbrownfox","equi")
>  pos=rinstr(a$,b$,x)
>  
>  Description
>  
>     The rinstr-function accepts two string-arguments and tries to find the
>     second   within   the   first.   However,   unlike   the   instr,  the
>     rinstr-function finds the rightmost (or last) occurence of the string;
>     whereas the instr-function finds the leftmost (or first) occurence. In
>     any case however, the position is counted from the left.
>  
>     If  you  supply  a  third, numeric argument to the rinstr-function, it
>     will   be   used  as  a  starting  point  for  the  search.  Therefore
>     rinstr("abcdeabcdeabcde","e",8)  will return 5, because the search for
>     an "e" starts at position 8 and finds the first one at position 5.
>  
>  Example
>  
>  print rinstr("foofoofoobar","foo")
>            
>  
>     This simple example will print 7, because it finds the rightmost among
>     the three occurences of foo within the string. Note, that
>  print instr("foofoofoobar","foo")
>  
>     would have printed 1.
>  
>  See also
>  
>     instr
>  
>  rtrim$()
>  
>  Name
>  
>     rtrim$() -- trim spaces at the right end of a string
>  
>  Synopsis
>  
>  a$=rtrim$(b$)
>  
>  Description
>  
>     The  rtrim$-function  removes  all wthitespace from the right end of a
>     string and returns the result.
>  
>  Example
>  
>  open 1,"foo"
>  dim lines$(100)
>  l=1
>  while(not eof(1))
>    input #1 a$
>    a$=rtrim$(a$)
>    if (right$(line$,1)="\\\\") then
>      line$=line$+" "+a$
>    else
>      lines$(l)=line$
>      l=l+1
>      line$=a$
>    endif
>  end while
>  print "Read ",l," lines"
>            
>  
>     This example reads the file foo allowing for continuation lines, which
>     are  marked by a \\, which appears as the last character on a line. For
>     convenience  whitespace  at  the  right  end of a line is trimmed with
>     rtrim.
>  
>  See also
>  
>     ltrim$, trim$
>  
>  S
>  
>     Table of Contents
>  
>     screen - as clear screen clears the text window
>     seek() - change the position within an open file
>     sig() - return the sign of its argument
>     sin() - return the sine of its single argument
>     sleep - pause, sleep, wait for the specified number of seconds
>     split() - split a string into many strings
>     sqr() - compute the square of its argument
>     sqrt() - compute the square root of its argument
>     static - preserves the value of a variable between calls to a
>            subroutine
>  
>     step - specifies the increment step in a for-loop
>     str$() - convert a number into a string
>     sub - declare a user defined subroutine
>     switch - select one of many alternatives depending on a value
>     system$() - hand a statement over to your operating system and return
>            its output
>  
>     system() - hand a statement over to your operating system and return
>            its exitcode
>  
>  screen
>  
>  Name
>  
>     screen -- as clear screen clears the text window
>  
>  Synopsis
>  
>  clear screen
>  
>  Description
>  
>     The  keyword  screen  appears  only  within the sequence clear screen;
>     please see there for a description.
>  
>  See also
>  
>     clear screen
>  
>  seek()
>  
>  Name
>  
>     seek() -- change the position within an open file
>  
>  Synopsis
>  
>  open 1,"foo"
>  seek #1,q
>  seek #1,x,"begin"
>  seek #1,y,"end"
>  seek #1,z,"here"
>  
>  Description
>  
>     The  seek-command changes the position, where the next input (or peek)
>     statement will read from an open file. Usually files are read from the
>     beginning  to  the end sequentially; however sometimes you may want to
>     depart   from   this   simple  scheme.  This  can  be  done  with  the
>     seek-command,  allowing  you  to  change  the position, where the next
>     piece of data will be read from the file.
>  
>     seek accepts two or three arguments: The first one is the number of an
>     already  open file. The second one is the position where the next read
>     from the file will start. The third argument is optional and specifies
>     the  the  point  from  where  the  position (the second argument) will
>     count. It can be one of:
>  
>     begin
>            Count from the beginning of the file.
>  
>     end
>            Count from the end of the file.
>  
>     here
>            Count from the current position within the file.
>  
>  Example
>  
>  open #1,"count.dat","w"
>  for a=1 to 10
>    print #1,"00000000";
>    if (a<10) print #1,";";
>  next a
>  
>  dim count(10)
>  do
>    x=int(ran(10))
>    i=i+1
>    if (mod(i,1000)=0) print ".";
>    count(x)=count(x)+1
>    curr$=right$("00000000"+str$(count(x)),8)
>    seek #1,9*x,"begin"
>    print #1,curr$;
>  loop
>            
>  
>     This  example  increments  randomly  one of ten counters (in the array
>     count());  however,  the  result is always kept and updated within the
>     file count.dat, so even in case of an unexpected interrupt, the result
>     will not be lost.
>  
>  See also
>  
>     tell, open, print, peek
>  
>  sig()
>  
>  Name
>  
>     sig() -- return the sign of its argument
>  
>  Synopsis
>  
>  a=sig(b)
>  
>  Description
>  
>     Return  +1,  -1  or 0, if the single argument is positive, negative or
>     zero.
>  
>  Example
>  
>  clear screen
>  dim c$(3):c$(1)="red":c$(2)="white":c$(3)="green"
>  do
>    num=ran(100)-50
>    print color(c$(2+sig(num))) num
>  loop
>            
>  
>     This  program  prints  an infinite sequence of random number; positive
>     numbers  are  printed  in  green, negative numbers are printed red (an
>     exact  zero  would  be printed white). (With a little extra work, this
>     program could be easily extended into a brogerage system)
>  
>  See also
>  
>     abs, int, frac
>  
>  sin()
>  
>  Name
>  
>     sin() -- return the sine of its single argument
>  
>  Synopsis
>  
>  y=sin(angle)
>  
>  Description
>  
>     The  sin-function expects an angle (in radian, not degree) and returns
>     its sine.
>  
>  Example
>  
>  open window 200,200
>  new curve
>  for phi=0 to 2*pi step 0.1
>    line to 100+90*sin(phi),100+90*cos(phi)
>  next phi
>  close curve
>            
>  
>     This   program   draws   a  circle  (ignoring  the  existence  of  the
>     circle-command).
>  
>  See also
>  
>     asin, cos
>  
>  sleep
>  
>  Name
>  
>     sleep -- pause, sleep, wait for the specified number of seconds
>  
>  Synopsis
>  
>  sleep 4
>  
>  Description
>  
>     The sleep-command has many different names: You may write pause, sleep
>     or  wait  interchangeably;  whatever you write, yabasic will always do
>     exactly the same.
>  
>     Therefore  you  should  refer  to the entry for the pause-function for
>     further information.
>  
>  split()
>  
>  Name
>  
>     split() -- split a string into many strings
>  
>  Synopsis
>  
>  dim w$(10)
>  ...
>  num=split(a$,w$())
>  num=split(a$,w$(),s$)
>  
>  Description
>  
>     The  split-function  requires  a  string  (containing  the  text to be
>     split),  a  reference  to  a  string-array  (which  will  receive  the
>     resulting strings, i.e. the tokens) and an optional string (with a set
>     of characters, at which to split, i.e. the delimiters).
>  
>     The  split-function  views  its first argument (a string) as a list of
>     tokens  separated  by  delimiters and it will store the list of tokens
>     within  the  array-reference  you have supplied; normally (i.e. if you
>     omit  the  third,  which  is the delimiter-argument) the function will
>     regard  space  or tab as delimiters for tokens; however by supplying a
>     third  argument,  you may split at any single of the characters within
>     this string. E.g. if you supply ":;" as the third argument, then colon
>     (:) or semicolon (;) will delimit tokens.
>  
>     Note,  that a sequence of separator-characters will produce a sequence
>     of  empty  tokens; that way, the number of tokens returned will always
>     be  one  plus  the number of separator characters contained within the
>     string.  Refer  to  the  closely related token-function, if you do not
>     like  this  behaviour.  In some way, the split-function focuses on the
>     separators  (other  than  the  token-function,  which  focuses  on the
>     tokens), hence its name.
>  
>     The second argument is a reference on a string-array, where the tokens
>     will be stored; this array will be expanded (or shrinked) to have room
>     for all tokens, if necessary.
>  
>     The  first argument finally contains the text, that will be split into
>     tokens. The split-function returns the number of tokens that have been
>     found.
>  
>     Please see the examples below for some hints on the exact behaviour of
>     the split-function and how it differs from the token-function:
>  
>  Example
>  
>  print "This program will help you to understand, how the"
>  print "split()-function exactly works and how it behaves"
>  print "in certain special cases."
>  print
>  print "Please enter a line containing tokens separated"
>  print "by either '=' or '-'"
>  dim t$(10)
>  do
>    print 
>    input "Please enter a line: " l$
>    num=split(l$,t$(),"=-")
>    print num," Tokens: ";
>    for a=1 to num
>      if (t$(a)="") then
>        print "(EMPTY)";
>      else 
>        print t$(a);
>      endif
>      if (a<num) print ","; 
>    next a
>    print
>  loop
>            
>  
>     This program prints the following output:
>  
>  Please enter a line: a
>  1 Tokens: a
>  
>  Please enter a line:
>  0 Tokens:
>  
>  Please enter a line: ab
>  1 Tokens: ab
>  
>  Please enter a line: a=b
>  2 Tokens: a,b
>  
>  Please enter a line: a-
>  2 Tokens: a,(EMPTY)
>  
>  Please enter a line: a-=
>  3 Tokens: a,(EMPTY),(EMPTY)
>  
>  Please enter a line: =a-
>  3 Tokens: (EMPTY),a,(EMPTY)
>  
>  Please enter a line: a=-b
>  3 Tokens: a,(EMPTY),b
>  
>  Please enter a line: a--b-
>  4 Tokens: a,(EMPTY),b,(EMPTY)
>  
>  Please enter a line: -a==b-c==
>  7 Tokens: (EMPTY),a,(EMPTY),b,c,(EMPTY),(EMPTY)
>  
>  See also
>  
>     token
>  
>  sqr()
>  
>  Name
>  
>     sqr() -- compute the square of its argument
>  
>  Synopsis
>  
>  a=sqr(b)
>  
>  Description
>  
>     The  sqr-function  computes the square of its numerical argument (i.e.
>     it multiplies its argument with itself).
>  
>  Example
>  
>  for a=1 to 10
>    print a,sqr(a),a**2
>  next a
>            
>  
>     As you may see from the output, sqr can be written as **2 (or ^2) too.
>  
>  See also
>  
>     sqrt, **, ^
>  
>  sqrt()
>  
>  Name
>  
>     sqrt() -- compute the square root of its argument
>  
>  Synopsis
>  
>  to be written
>  
>  Description
>  
>     The sqrt-function computes the square root of its numerical argument.
>  
>  Example
>  
>  for a=1 to 5
>    print a,sqrt(a),a**(1/2)
>  next a
>            
>  
>     As  you  may  see  from the output, sqrt can be written as **(1/2) (or
>     ^(1/2)) too.
>  
>  See also
>  
>     sqr, **, ^
>  
>  static
>  
>  Name
>  
>     static --  preserves  the  value  of  a  variable  between calls to a
>     subroutine
>  
>  Synopsis
>  
>  sub foo()
>  
>    static a
>  
>    ...
>  
>  end sub 
>  
>  Description
>  
>     The static keyword can be used within subroutines to mark variables as
>     static.  This  has  two  effects:  First, the variable is local to the
>     subroutine, i.e. its value is not know outside the subroutine (this is
>     the  effect of the local keyword). Second, the static-keyword arranges
>     things,  so  that  the variable keeps its value between invocations of
>     the subroutine (this is different from the local-keyword).
>  
>  Example
>  
>  foo()
>  foo()
>  foo()
>  
>  sub foo()
>    static a
>    local b
>    a=a+1
>    b=b+1
>    print a,b
>  end sub
>            
>  
>     This  program  shows the difference between static and local variables
>     within a subroutine; it produces this output:
>  
>  1 1
>  2 1
>  3 1
>  
>     The  output  shows, that the static variable a keeps its value between
>     subroutine  calls,  whereas b is initialized with the value 0 at every
>     call to the subroutine foo.
>  
>  See also
>  
>     sub, local
>  
>  step
>  
>  Name
>  
>     step -- specifies the increment step in a for-loop
>  
>  Synopsis
>  
>  for a=1 to 10 step 3
>    ...
>  next a
>  
>  Description
>  
>     Specify,  by  which  amount  the  loop-variable  of a for-loop will be
>     incremented at each step.
>  
>     The  step  (as well as the lower and upper bound) are computed anew in
>     each  step;  this  is  not  common, but possible, as the example below
>     demonstrates.
>  
>  Example
>  
>  for x=1 to 1000 step y
>    y=x+y
>    print x," ",y," ";
>  next x
>  print
>            
>  
>     This program computes the fibonacci numbers between 1 and 1000.
>  
>  See also
>  
>     for
>  
>  str$()
>  
>  Name
>  
>     str$() -- convert a number into a string
>  
>  Synopsis
>  
>  a$=str$(a)
>  b$=str$(x,"##.###")
>  
>  Description
>  
>     The  str$-function  accepts  a  numeric  argument  and returns it as a
>     string.  This  conversion  between number and string can be controlled
>     with  the  optional  third  argument  (the  format  argument). See the
>     following  table  of  examples  to  learn  about  valid values of this
>     argument.  Note,  that  those  examples fall in one of two categories:
>     C-style  and  basic-style; the first 4 examples in the table below are
>     C-style,   the   rest  of  the  examples  are  basic-style.  For  more
>     information  on  the  C-style  formats, you may refer to your favorite
>     documentation  on  the C programming language. The basic-style formats
>     are  much simpler, they just depict the desired output, marking digits
>     with '#'.
>  
>     Note,  that for clarity, each space in the result has been replaced by
>     the  letter  'x',  because  it  would  be hard to figure out, how many
>     spaces are produced exactly otherwise.
>  
>     Table 5.2. Examples for the format argument
>     Example string Result for converting 1000*pi Description
>     %2.5f 3141.59265 The '2' determines the minimum length of the output;
>     but if needed (as in the example) the output can be longer. The '5' is
>     the number of digits after the decimal point.
>     %12.5f  xx3141.59265 Two spaces (which appear as 'x') are added to pad
>     the output to the requested length of 12 characters.
>     %012.5g  0000003141.6  The  'g'  requests,  that  the  precision ('5')
>     specifies  the  overall number of digits (before and after the decimal
>     point).
>     %-12.5f  3141.59265xx  The '-' requests the output to be left-centered
>     (therefor the filling space appears at thi right).
>     #####.##  x3141.59  Each '#' specifies a digit (either before or after
>     the  dot),  the '.' specifies the position of the dot. As 1000*pi does
>     not  have  enough  digits,  the  5 requested digits before the dot are
>     filled up with a space (which shows up as an 'x').
>     #####  x3142  Each  '#'  specifies a digit (either before or after the
>     dot),  the  '.' specifies the position of the dot. As 1000*pi does not
>     have  enough  digits, the 5 requested digits before the dot are filled
>     up with a space (which shows up as a 'x').
>     ##.###  ******  As 1000*pi has 4 digits infront of the decimal dot and
>     the  format  only  specifies  2,  yabasic  does  not  know what to do;
>     therefore it chooses to fill it all up with stars '*'.
>  
>  Example
>  
>  do
>    input "Please enter a format string: " f$
>    a$=str$(1000*pi,f$)
>    for a=1 to len(a$)
>      if (mid$(a$,a,1)=" ") mid$(a$,a,1)="x"
>    next a
>    print a$
>  loop
>            
>  
>     This  is  the  program, that has been used to get the results shown in
>     the table above.
>  
>  See also
>  
>     print, using
>  
>  sub
>  
>  Name
>  
>     sub -- declare a user defined subroutine
>  
>  Synopsis
>  
>  foo(2,"hello")
>  
>  ...
>  
>  sub foo(bar,baz$)
>    ...
>    return qux
>    ...
>  end sub
>  
>  Description
>  
>     The  sub-keyword  starts  the definition of a user defined subroutine.
>     With  user defined subroutines you are able to somewhat extend yabasic
>     with  your  own  commands or functions. A subroutine accepts arguments
>     (numbers  or  strings)  and returns a number or a string (however, you
>     are not required to assign the value returned to a variable).
>  
>     The  name of the subroutine follows after the keyword sub. If the name
>     (in  the  synopsis: foo) ends on a '$', the subroutine should return a
>     string (with the return-statement), otherwise a number.
>  
>     After  the  name  of the subroutine yabasic requires a pair of braces;
>     within  those  braces  you may specify a list of parameters, for which
>     values  can (but need not) be included when calling the subroutine. If
>     you  omit  one  of those parameters when calling such a subroutine, it
>     assumes  the  value  zero (for numeric parameters) or the empty string
>     (for  string-parameters).  However  with peek("argument") you may find
>     out,  how  many  arguments  have  really been passed while calling the
>     subroutine.
>  
>     Parameters of a subroutine are always local variables (see the keyword
>     local for more explanation).
>  
>     From  within  the  subroutine you may return any time with the keyword
>     return;  along  with  the  return-keyword  you  may specify the return
>     value.  Note  that  more  than  one  return is allowed within a single
>     subroutine.
>  
>     Finally,  the  keyword  end  sub ends the subroutine definition. Note,
>     that the definition of a subroutine need not appear within the program
>     before the first call to this sub.
>  
>  Note
>  
>     As  braces have two uses in yabasic (i.e. for supplying arguments to a
>     subroutine  as  well  as to list the indices of an array). yabasic can
>     not  tell  apart  an  array  from  a  subroutine  with  the same name.
>     Therefore  you  cannot  define  a  subroutine with the same name as an
>     array !
>  
>  Example
>  
>  p=2
>  do 
>    if (is_prime(p)) print p
>    p=p+1
>  loop
>  
>  sub is_prime(a)
>    local b
>    for b=2 to sqrt(a)
>      if (frac(a/b)=0) return false
>    next b
>    return true
>  end sub
>            
>  
>     This  example  is  not  the  recommended way to compute prime numbers.
>     However it gives a nice demonstration of using a subroutine.
>  
>  See also
>  
>     local, static, peek
>  
>  switch
>  
>  Name
>  
>     switch -- select one of many alternatives depending on a value
>  
>  Synopsis
>  
>  switch a
>    case 1
>    case 2
>    ...
>  end switch
>  
>  ...
>  
>  switch a$
>    case "a"
>    case "b"
>  end switch
>  
>  Description
>  
>     The  switch-statment  selects  one  of  many  codepaths depending on a
>     numerical  or  string  expression. I.e. it takes an expression (either
>     numeric  or  string)  and  compares  it  with a series of values, each
>     wrapped within a case-clause. If the expression equals the value given
>     in a case-clause, the subsequent statements are executed.
>  
>     The  default-clause  allows  to  specify  commands,  which  should  be
>     executed, if none of case-clauses matches.
>  
>     Note,  that  many  case-clauses might be clustered (e.g. case "a":case
>     "b":case  "c").  Or put another way: You need a break-statement at the
>     end of a case-branch, if you do not want to run into the next case.
>  
>  Example
>  
>  input "Please enter a single digit: " n
>  switch n
>    case 0:print "zero":break
>    case 1:print "one":break
>    case 2:print "two":break
>    case 3:print "three":break
>    case 4:print "four":break
>    case 5:case 6: case 7:case 8:case 9
>      print "Much !":break
>    default:print "Hey ! That was more than a single digit !"
>  end switch 
>            
>  
>     This  example  translates  a single digit into a string; note, how the
>     cases 5 to 7 are clustered.
>  
>  See also
>  
>     switch, case, break
>  
>  system$()
>  
>  Name
>  
>     system$() -- hand a statement over to your operating system and return
>     its output
>  
>  Synopsis
>  
>  print system$("dir")
>  
>  Description
>  
>     The  system$-command  accepts  a  single string argument, specifying a
>     command,  that  can be found and executed by your operating system. It
>     returns the output of this command as one big string.
>  
>  Example
>  
>  input "Please enter the name of a directory: " d$
>  print
>  print "This is the contents of the '"+d$+"':"
>  print system$("dir "+d$)
>            
>  
>     This  example  lists  the  contents  of  a  directory,  employing  the
>     dir-command (which is about the only program, that is known under Unix
>     as well as Windows).
>  
>  See also
>  
>     system
>  
>  system()
>  
>  Name
>  
>     system() -- hand a statement over to your operating system and return
>     its exitcode
>  
>  Synopsis
>  
>  ret=system("foo")
>  system("bar")
>  
>  Description
>  
>     The system-command accepts a single string argument, which specifies a
>     command  to  be executed. The function will return the exitcode of the
>     command; its output (if any) will be lost.
>  
>  Example
>  
>  print "Please enter the name of the file, that should be deleted."
>  input f$
>  if (system("rm "+f$+" >/dev/null 2>&1")) then
>    print "Error !"
>  else
>    print "okay."
>  endif
>            
>  
>     This program is Unix-specific: It uses the Unix-command rm to remove a
>     file.
>  
>  See also
>  
>     system$
>  
>  T
>  
>     Table of Contents
>  
>     tan() - return the tangens of its argument
>     tell - get the current position within an open file
>     text - write text into your graphic-window
>     then - tell the long from the short form of the if-statement
>     time$ - return a string containing the current time
>     to - this keyword appears as part of other statements
>     token() - split a string into multiple strings
>     trim$() - remove leading and trailing spaces from its argument
>     true - a constant with the value of 1
>  
>  tan()
>  
>  Name
>  
>     tan() -- return the tangens of its argument
>  
>  Synopsis
>  
>  foo=tan(bar)
>  
>  Description
>  
>     The  tan-function  computes the tangens of its arguments (which should
>     be specified in radian).
>  
>  Example
>  
>  for a=0 to 45
>    print tan(a*pi/180)
>  next a
>            
>  
>     This  example simply prints the tangens of all angles between 0 and 45
>     degree.
>  
>  See also
>  
>     atan, sin
>  
>  tell
>  
>  Name
>  
>     tell -- get the current position within an open file
>  
>  Synopsis
>  
>  open #1,"foo"
>    ...
>  position=tell(#1)
>  
>  Description
>  
>     The  tell-function requires the number of an open file as an argument.
>     It returns the position (counted in bytes, starting from the beginning
>     of the file) where the next read will start.
>  
>  Example
>  
>  open #1,"foo","w"
>  print #1 "Hello World !"
>  close #1
>  
>  open #1,"foo"
>  seek #1,0,"end"
>  print tell(#1)
>  close 1
>            
>  
>     This  example  (mis)uses  tell  to  get the size of the file. The seek
>     positions  the  file pointer at the end of the file, therefor the call
>     to tell returns the total length of the file.
>  
>  See also
>  
>     tell, open
>  
>  text
>  
>  Name
>  
>     text -- write text into your graphic-window
>  
>  Synopsis
>  
>  text x,y,"foo"
>  text x,y,"foo","l"
>  
>  Description
>  
>     The  text-function  displays a text-string (the third argument) at the
>     given  position  (the  first  two  arguments) within an already opened
>     window.  There  is no way to specify a font for the text, that will be
>     written  (this  font can only be specified once, as an argument to the
>     open window-statement).
>  
>     The  fourth, optional argument can be used to specify the alignment of
>     the  text  with  respect  to  the specified position. This argument is
>     always   two  characters  long:  The  first  character  specifies  the
>     horizontal  alignment  and  can  be  either l, r or c, which stand for
>     left,  right  or  center.  The second character specifies the vertical
>     alignment  and can be one of t, b or c, which stand for top, bottom or
>     center  respectively. If you omit this alignment argument, the default
>     "lb"   applies;   however  this  default  may  be  changed  with  poke
>     "textalign","xx"
>  
>  Example
>  
>  open window 500,200
>  clear screen
>  data "lt","lc","lb","ct","cc","cb","rt","rc","rb"
>  for a=1 to 9
>    read align$   
>    print "Alignment: ",align$
>    line 50*a-15,100,50*a+15,100
>    line 50*a,85,50*a,115
>    text 50*a,100,"Test",align$
>    inkey$ 
>  next a
>            
>  
>     This  program  draws  nine  crosses  and writes the same text at each;
>     however  it  goes through all possible nine alignment strings, showing
>     their effect.
>  
>  See also
>  
>     open window, peek, poke
>  
>  then
>  
>  Name
>  
>     then -- tell the long from the short form of the if-statement
>  
>  Synopsis
>  
>  if (a<b) then
>    ...
>  endif
>  
>  Description
>  
>     The  keyword  then  is  part of the if-statement; please see there for
>     further  explanations.  However,  not  every if-statement requires the
>     keyword then: If the keyword then is present, the if-clause may extend
>     over  more than one line, and the keyword endif is required to end it.
>     If the keyword then is not present, the if-statement extends up to the
>     end of the line, and any endif would be an error.
>  
>  Example
>  
>  if (1<2) then 
>    print "Hello ";
>  endif
>  
>  if (2<3) print "world"
>  if (2<1)
>    print "!"
>            
>  
>     This example prints Hello world. Note, that no exclamation mark (!) is
>     printed,  which  might come as a surprise and may be changed in future
>     versions of yabasic.
>  
>  See also
>  
>     if
>  
>  time$
>  
>  Name
>  
>     time$ -- return a string containing the current time
>  
>  Synopsis
>  
>  print time$
>  print time$()
>  
>  Description
>  
>     The  time$  function returns the current time in four fields separated
>     by hyphens '-'. The fields are:
>  
>       * The  current  hour  in  the range from 0 to 23, padded with zeroes
>         (e.g. 00 or 04) to a length of two characters.
>       * The number of minutes, padded with zeroes.
>       * The number of seconds, padded with zeroes.
>       * The  number  of  seconds,  that have elapsed since the program has
>         been  started.  This  value encreases as long as your program runs
>         and is therefore unbound and not padded with zeroes.
>  
>     At  the  time of writing this documentation, time$ returns 22-58-53-0.
>     Note, that the first three of the four fields returned by time$ have a
>     fixed  width;  therefore  it  is  easy to extract some fields with the
>     usual string-functions mid$ (and others).
>  
>  Example
>  
>  print "Hello it is ",time$
>  print "An empty for-loop with ten million iterations takes ";
>  s=val(mid$(time$,10))
>  for a=1 to 10000000:next a
>  e=val(mid$(time$,10))
>  print e-s," seconds"
>            
>  
>     This  program benchmarks the for-loop and uses the fourth field of the
>     string returned by time$.
>  
>  See also
>  
>     date
>  
>  to
>  
>  Name
>  
>     to -- this keyword appears as part of other statements
>  
>  Synopsis
>  
>  for a=1 to 100 step 2
>    ...
>  next a
>  
>  line x,y to a,b
>  
>  Description
>  
>     The to-keyword serves two purposes (which are not related at all):
>       * within for-statements, to specify the upper bound of the loop.
>       * Within any graphical command (e.g. line), that requires two points
>         (i.e.  four  numbers)  as arguments, a comma ',' might be replaced
>         with the keyword to. I.e. instead of 100,100,200,200 you may write
>         100,100 to 200,200 in such commands.
>  
>  Example
>  
>     Pleas see the command listed under "See also" for examples.
>  
>  See also
>  
>     for, line, rectangle
>  
>  token()
>  
>  Name
>  
>     token() -- split a string into multiple strings
>  
>  Synopsis
>  
>  dim w$(10)
>  ...
>  num=token(a$,w$())
>  num=token(a$,w$(),s$)
>  
>  Description
>  
>     The token-function accepts a string (containing the text to be split),
>     a  reference  to  a  string-array  (which  will  receive the resulting
>     strings,  i.e.  the  tokens)  and  an  optional  string (with a set of
>     characters, at which to split, i.e. the delimiters).
>  
>     The  token-function  regards  its  first  argument as a list of tokens
>     separated  by  delimiters  and it will store the list of tokens within
>     the array-reference that has been supplied; normally (i.e. if you omit
>     the  third,  the delimiter-argument) the function will regard space or
>     tab  as  delimiters for tokens; however by supplying a third argument,
>     you may split at any single of the characters within this string. E.g.
>     if  you supply ":;" as the third argument, then colon (:) or semicolon
>     (;) will delimit tokens.
>  
>     Note,  that token will never produce empty tokens, even if two or more
>     separators   follow   in   sequence.  Refer  to  the  closely  related
>     split-function,  if  you  do not like this behaviour. In some way, the
>     token-function  focuses on the tokens and not on the separators (other
>     than the split-function, which focuses on the separators).
>  
>     The second argument is a reference on a string-array, where the tokens
>     will be stored; this array will be expanded (or shrinked) as necessary
>     to have room for all tokens.
>  
>     The  first argument finally contains the text, that will be split into
>     tokens.  The  token-function  returns  the number of tokens, that have
>     been found.
>  
>     Please see the examples below for some hints on the exact behaviour of
>     the token-function and how it differs from the split-function:
>  
>  Example
>  
>  print "This program will help you to understand, how the"
>  print "token()-function exactly works and how it behaves"
>  print "in certain special cases."
>  print
>  print "Please enter a line containing tokens separated"
>  print "by either '=' or '-'"
>  dim t$(10)
>  do
>    print 
>    input "Please enter a line: " l$
>    num=token(l$,t$(),"=-")
>    print num," Tokens: ";
>    for a=1 to num
>      if (t$(a)="") then
>        print "(EMPTY)";
>      else 
>        print t$(a);
>      endif
>      if (a<num) print ","; 
>    next a
>    print
>  loop
>            
>  
>     This program prints the following output:
>  
>  Please enter a line: a
>  1 Tokens: a
>  
>  Please enter a line:
>  0 Tokens:
>  
>  Please enter a line: ab
>  1 Tokens: ab
>  
>  Please enter a line: a=b
>  2 Tokens: a,b
>  
>  Please enter a line: a-
>  1 Tokens: a
>  
>  Please enter a line: a-=
>  1 Tokens: a
>  
>  Please enter a line: =a-
>  1 Tokens: a
>  
>  Please enter a line: a=-b
>  2 Tokens: a,b
>  
>  Please enter a line: a--b-
>  2 Tokens: a,b
>  
>  Please enter a line: -a==b-c==
>  3 Tokens: a,b,c
>  
>  See also
>  
>     split
>  
>  trim$()
>  
>  Name
>  
>     trim$() -- remove leading and trailing spaces from its argument
>  
>  Synopsis
>  
>  a$=trim$(b$)
>  
>  Description
>  
>     The  trim$-function removes all whitespaces from the left and from the
>     right  end  of  a  string  and  returns  the  result. Calling trim$ is
>     equivalent to calling rtrim$(ltrim$()).
>  
>  Example
>  
>  do
>    input "Continue ? Please answer yes or no: " a$
>    a$=lower$(trim$(a$))
>    if (len(a$)>0 and a$=left$("no",length(a$)) exit
>  loop
>            
>  
>     This  example  asks  for an answer (yes or no) and removes spaces with
>     trim$ to make the comparison with the string "no" more bulletproof.
>  
>  See also
>  
>     ltrim$, rtrim$
>  
>  true
>  
>  Name
>  
>     true -- a constant with the value of 1
>  
>  Synopsis
>  
>  okay=true
>  
>  Description
>  
>     The constant true can be assigned to variables which will later appear
>     in conditions (e.g. an if-statement.
>  
>     true may also be written as TRUE or even TrUe.
>  
>  Example
>  
>  input "Please enter a string of all upper letters: " a$
>  if (is_upper(a$)) print "Okay"
>  
>  sub is_upper(a$)
>    if (a$=upper$(a$)) return true
>    return false
>  end sub
>            
>  
>  See also
>  
>     false
>  
>  U
>  
>     Table of Contents
>  
>     until - end a repeat-loop
>     upper$() - convert a string to upper case
>     using - Specify the format for printing a number
>  
>  until
>  
>  Name
>  
>     until -- end a repeat-loop
>  
>  Synopsis
>  
>  repeat 
>    ...
>  until (...)
>  
>  Description
>  
>     The  until-keyword  ends  a  loop,  which  has  been introduced by the
>     repeat-keyword.   until   requires   a  condition  in  braces  (or  an
>     expression,  see  here  for  details)  as  an  argument; the loop will
>     continue until this condition evaluates to true.
>  
>  Example
>  
>  c=1
>  s=1
>  repeat
>    l=c
>    s=-(s+sig(s))
>    c=c+1/s
>    print c
>  until(abs(l-c)<0.000001)
>            
>  
>     This  program calculates the sequence 1/1-1/2+1/3-1/4+1/5-1/6+1/7-1/8+
>     ...  ;  please  let  me  know,  if  you  know against which value this
>     converges.
>  
>  See also
>  
>     repeat
>  
>  upper$()
>  
>  Name
>  
>     upper$() -- convert a string to upper case
>  
>  Synopsis
>  
>  u$=upper$(a$)
>  
>  Description
>  
>     The  upper$-function  accepts a single string argument and converts it
>     to all upper case.
>  
>  Example
>  
>  line input "Please enter a sentence without the letter 'e': " l$
>  p=instr(upper$(l$),"E")
>  if (p) then
>    l$=lower$(l$)
>    mid$(l$,p,1)="E"
>    print "Hey, you are wrong, see here!"
>    print l$
>  else
>    print "Thanks."
>  endif
>            
>  
>     This  program  asks  for  a  sentence  and  marks  the  first (if any)
>     occurence of the letter 'e' by coverting it to upper case (in contrast
>     to the rest of the sentence, which is converted to lower case).
>  
>  See also
>  
>     lower$
>  
>  using
>  
>  Name
>  
>     using -- Specify the format for printing a number
>  
>  Synopsis
>  
>  print a using "##.###"
>  
>  Description
>  
>     The  using-keyword  may  appear  as  part  of  the print-statement and
>     specifies  the  format (e.g. the number of digits before and after the
>     decimal dot), which should be used to print the number.
>  
>     The  possible values for the format argument ("##.###" in the synopsis
>     above)  are  described within the entry for the str$-function. In fact
>     the  using  clause is closely related to the str$-function; the former
>     can always be rewritten using the latter; i.e. print foo using bar$ is
>     always  equivalent to print str$(foo,bar$). Therefore you should check
>     out str$ to learn more.
>  
>  Example
>  
>  for a=1 to 10
>    print sqrt(ran(10000*a)) using "#########.#####"
>  next a
>            
>  
>     This  example prints a column of square roots of random number, nicely
>     aligned at the decimal dot.
>  
>  See also
>  
>     print, str$
>  
>  V
>  
>     Table of Contents
>  
>     val() - converts a string to a number
>  
>  val()
>  
>  Name
>  
>     val() -- converts a string to a number
>  
>  Synopsis
>  
>  x=val(x$)
>  
>  Description
>  
>     The  val-function  checks, if the start of its string argument forms a
>     floating  point  number  and  then  returns  this  number.  The string
>     therefore  has  to  start  with  digits  (only  whitespace  infront is
>     allowed), otherwise the val-function returns zero.
>  
>  Example
>  
>  input "Please enter a length, either in inches (in) or centimeters (cm) " l$
>  if (right$(l$,2)="in") then
>    l=val(l$)*2.51
>  else
>    l=val(l$)
>  print "You have entered ",l,"cm."
>            
>  
>     This example queries for a length and checks, if it has been specified
>     in inches or centimeters. The length is then converted to centimeters.
>  
>  See also
>  
>     str$
>  
>  W
>  
>     Table of Contents
>  
>     wait - pause, sleep, wait for the specified number of seconds
>     wend - end a while-loop
>     while - start a while-loop
>     window origin - move the origin of a window
>  
>  wait
>  
>  Name
>  
>     wait -- pause, sleep, wait for the specified number of seconds
>  
>  Synopsis
>  
>  wait 4
>  
>  Description
>  
>     The  wait-command has many different names: You may write pause, sleep
>     or  wait  interchangeably;  whatever you write, yabasic will always do
>     exactly the same.
>  
>     Therefore  you  should  refer  to the entry for the pause-function for
>     further information.
>  
>  wend
>  
>  Name
>  
>     wend -- end a while-loop
>  
>  Synopsis
>  
>  while(a<b)
>    ...
>  wend
>  
>  Description
>  
>     The  wend-keyword  marks  the  end  of  a  while-loop.  Please see the
>     while-keyword for more details.
>  
>     wend can be written as end while or even end-while.
>  
>  Example
>  
>  line input "Please enter a sentence: " a$
>  p=instr(a$,"e")
>  while(p)
>    mid$(a$,p,1)="E"
>    p=instr(a$,"e")
>  wend
>  print a$
>            
>  
>     This  example  reads  a  sentence  and converts every occurence of the
>     letter e into uppercase (E).
>  
>  See also
>  
>     while (which is just the following entry).
>  
>  while
>  
>  Name
>  
>     while -- start a while-loop
>  
>  Synopsis
>  
>  while(...)
>    ...
>  wend
>  
>  Description
>  
>     The  while-keyword starts a while-loop, i.e. a loop that is excuted as
>     long  as the condition (which is specified in braces after the keyword
>     while) evaluates to true.
>  
>     Note,  that the body of such a while-loop will not be executed at all,
>     if the condition following the while-keyword is not true initially.
>  
>     If   you  want  to  leave  the  loop  prematurely,  you  may  use  the
>     break-statement.
>  
>  Example
>  
>  open #1,"foo"
>  while(!eof(1))
>    line input #1 a$
>    print a$
>  wend
>            
>  
>     This program reads the file foo and prints it line by line.
>  
>  See also
>  
>     until, break, wend, do
>  
>  window origin
>  
>  Name
>  
>     origin -- move the origin of a window
>  
>  Synopsis
>  
>  open window 200,200
>  origin "cc"
>  
>  Description
>  
>     The  origin-command applies to graphic windows and moves the origin of
>     the  coordinate  system  to  one  of nine point within the window. The
>     normal  position  of  the  origin  is  in the upper left corner of the
>     window;  however  in  some  cases  this is inconvenient and moving the
>     origin  may  save  you from substracting a constant offset from all of
>     your coordinates.
>  
>     However,  you  may  not  move  the origin to an arbitrary position; in
>     horizontal  possition there are only three positions: left, center and
>     right,  which  are  decoded  by  the  letters  l, c and r. In vertical
>     position  the allowed positions are top, center and bottom; encoded by
>     the  letters  t, c and b. Taking the letters together, you arrive at a
>     string, which might be passed as an argument to the command; e.g. "cc"
>     or "rt".
>  
>  Example
>  
>     100,100
>  open window 200,200
>  window origin "cc"
>  circle 0,0,60
>            
>  
>     This example draws a circle, centered at the center of the window.
>  
>  See also
>  
>     open window
>  
>  X
>  
>     Table of Contents
>  
>     xor() - compute the exclusive or
>  
>  xor()
>  
>  Name
>  
>     xor() -- compute the exclusive or
>  
>  Synopsis
>  
>  x=xor(a,b)
>  
>  Description
>  
>     The  xor  computes  the  bitwise  exclusive  or  of  its  two  numeric
>     arguments.  To  understand the result, both arguments should be viewed
>     as binary numbers (i.e. a series of 0 and 1); a bit of the result will
>     then  be  1,  if exactly one argument has a 1 and the other has a 0 at
>     this position in their binary representation.
>  
>     Note, that both arguments are silently converted to integer values and
>     that  negative  numbers  have  their own binary representation and may
>     lead to unexpected results when passed to and.
>  
>  Example
>  
>  print xor(7,4)
>            
>  
>     This  will  print  3.  This  result  is obvious, if you note, that the
>     binary  representation  of  7 and 4 are 111 and 100 respectively; this
>     will yield 011 in binary representaion or 2 as decimal.
>  
>     The eor-function is the same as the xor function; both are synonymous;
>     however they have each their own description, so you may check out the
>     entry of eor for a slightly different view.
>  
>  See also
>  
>     and, or, eor, not
>  
>  Special characters
>  
>     Table of Contents
>  
>     # - either a comment or a marker for a file-number
>     // - starts a comment
>     @ - synonymous to at
>     : - separate commands from each other
>     ; - suppress the implicit newline after a print-statement
>     ** or ^ - raise its first argument to the power of its second
>  
>  #
>  
>  Name
>  
>     # -- either a comment or a marker for a file-number
>  
>  Synopsis
>  
>  # This is a comment, but the line below not !
>  open #1,"foo"
>  
>  Description
>  
>     The hash ('#') has two totally unrelated uses:
>       * A hash might appear in commands related with file-io. yabasic uses
>         simple  numbers  to refer to open files (within input, print, peek
>         or  eof). In those commands the hash may precede the number, which
>         species   the   file.   Please  see  those  commands  for  further
>         information  and  examples;  the  rest  of this entry is about the
>         second use (as a comment).
>       * As  the  very  first  character  within  a line, a hash introduces
>         comments (similar to rem).
>  
>     '#'  as  a  comment  is  common  in most scripting languages and has a
>     special  use  under  Unix:  If the very first line of any Unix-program
>     begins  with  the  character  sequence  '#!'  ("she-bang",  no  spaces
>     allowed),  the rest of the line is taken as the program that should be
>     used  to  execute the script. I.e. if your yabasic-program starts with
>     '#!/usr/local/bin/yabasic', the program /usr/local/bin/yabasic will be
>     invoked  to  execute  the  rest  of  the  program.  As  a  remark  for
>     windows-users: This mechanism ensures, that yabasic will be invoked to
>     execute  your  program;  the  ending  of  the file (e.g. .yab) will be
>     ignored by Unix.
>  
>  Example
>  
>  # This line is a valid comment
>  print "Hello " : # But this is a syntax error, because
>  print "World!" : # the hash is not the first character !
>            
>  
>     Note, that this example will produce a syntax error and is not a valid
>     program !
>  
>  See also
>  
>     input, print, peek or eof, //, rem
>  
>  //
>  
>  Name
>  
>     // -- starts a comment
>  
>  Synopsis
>  
>  //  This is a comment !
>  
>  Description
>  
>     The  double-slash  ('//')  is  (besides  REM and '#') the third way to
>     start  a  comment.  '//'  is  the  latest and greatest in the field of
>     commenting  and  allows  yabasic  to catch up with such cool languages
>     like C++ and Java.
>  
>  Example
>  
>  // Another comment.
>  print "Hello world !" // Another comment
>            
>  
>     Unlike the example given for '#' this example is syntactically correct
>     and will not produce an error.
>  
>  See also
>  
>     #, rem
>  
>  @
>  
>  Name
>  
>     @ -- synonymous to at
>  
>  Synopsis
>  
>  clear screen
>  ...
>  print @(a,b)
>  
>  Description
>  
>     As  '@'  is  simply  a  synonym  for  at,  please  see  at for further
>     information.
>  
>  See also
>  
>     at
>  
>  :
>  
>  Name
>  
>     : -- separate commands from each other
>  
>  Synopsis
>  
>  print "Hello ":print "World"
>  
>  Description
>  
>     The colon (':') separates multiple commands on a single line.
>  
>     The  colon and the newline-character have mostly the same effect, only
>     that  the  latter,  well,  starts  a  new  line  too.  The  only other
>     difference  is  their effect within the (so-called) short if, which is
>     an  if-statement without the keyword then. Please see the entry for if
>     for more details.
>  
>  Example
>  
>  if (a<10) print "Hello ":print "World !"
>            
>  
>     This  example demonstrates the difference between colon and newline as
>     described above.
>  
>  See also
>  
>     if
>  
>  ;
>  
>  Name
>  
>     ; -- suppress the implicit newline after a print-statement
>  
>  Synopsis
>  
>  print "foo",bar;
>  
>  Description
>  
>     The  semicolon  (';')  may  only  appear at the last position within a
>     print-statement.  It  supresses  the  implicit  newline, which yabasic
>     normally adds after each print-statement.
>  
>     Put  another  way: Normally the output of each print-statement appears
>     on  a  line  by  itself.  If  you  rather  want  the  output  of  many
>     print-statements  to  appear  on  a  single  line,  you should end the
>     print-statement with a semicolon.
>  
>  Example
>  
>  print "Hello ";:print "World !"
>            
>  
>     This example prints Hello World ! in a single line.
>  
>  See also
>  
>     print
>  
>  ** or ^
>  
>  Name
>  
>     ** or ^ -- raise its first argument to the power of its second
>  
>  Synopsis
>  
>  print 2**b
>  print 3^4
>  
>  Description
>  
>     **  (or  ^,  which is an exact synonym), is the arithmetic operator of
>     exponentiation; it requires one number to its left and a second one to
>     its  right;  **  then  raises  the  first argument to the power of the
>     second  and returns the result. The result will only be computed if it
>     yields  a  real  number  (as opposed to a complex number); this means,
>     that  the power can not be computed, if the first argument is negative
>     and  the  second  one  is  fractional.  On  the other hand, the second
>     argument can be fractional, if the first one ist positive; this means,
>     that  **  may be used to compute arbitrary roots: e.g. x**0.5 computes
>     the square root of x.
>  
>  Example
>  
>  print 2**0.5
>            
>  
>  See also
>  
>     sqrt
>  
>  Chapter 6. A grab-bag of some general concepts and terms
>  
>     Table of Contents
>  
>     Logical shortcuts
>     Conditions and expressions
>     References on arrays
>     Specifying Filenames under Windows
>     Escape-sequences
>  
>     This chapter presents some general concepts and terms, which deserve a
>     description on their own, but are not associated with a single command
>     or function in yabasic. Most of these topics do not lend themselves to
>     be  read  alone,  rather they might be read (or skimmed) as background
>     material  if an entry from the alphabetical list of commands refers to
>     them.
>  
>  Logical shortcuts
>  
>     Logical  shortcuts  are  no special language construct and there is no
>     keyword for them; they are just a way to evaluate logical expressions.
>     Logical expressions (i.e. a series of conditions or comparisons joined
>     by  and  or  or)  are  only  evaluated  until  the final result of the
>     expression can be determined. An example:
>  if (a<>0 and b/a>2) print "b is at least twice as big as a"
>  
>     The  logical  expression  a<>0  and b/a>2 consists of two comparisons,
>     both of which must be true, if the print statement should be executed.
>     Now,  if  the  first  comparison  (a<>0)  is  false, the whole logical
>     expression  can  never  be true and the second comparison (b/a>2) need
>     not be evaluated.
>  
>     This  is  exactly,  how  yabasic behaves: The evaluation of a composed
>     logical  expressions  is  terminated immediately, as soon as the final
>     result can be deduced from the already evaluated parts.
>  
>     In practice, this has the following consequences:
>       * If  two or more comparisons are joined with and and one comparison
>         results  in  false, the logical expression is evaluated no further
>         and the overall result is false.
>       * If  two  or more comparisons are joined with or and one comparison
>         results  in  true,  the logical expression is evaluated no further
>         and the result is true.
>  
>     "Nice,  but  whats  this  good for ?", I hear you say. Well, just have
>     another look at the example, especially the second comparison (b/a>2);
>     deviding  b  by  a  is  potentially  hazardous:  If a equals zero, the
>     expression  will  cause  an  error and your program will terminate. To
>     avoid  this,  the  first  part of the comparison (a<>0) checks, if the
>     second  one  can  be  evaluated without risk. This pre-checking is the
>     most  common  usage  and primary motivation for logical shortcuts (and
>     the reason why most programming languages implement them).
>  
>  Conditions and expressions
>  
>     Well,  bottomline  there  is  no  difference  or  distinction  between
>     conditions  and  expressions, at least as yabasic is concerned. So you
>     may assign the result of comparisons to variables or use an arithmetic
>     expression  or  a  simple  variable within a condition (e.g. within an
>     if-statement).  So  the  constructs shown in the example below are all
>     totally valid:
>  input "Please enter a number between 1 and 10: " a
>  
>  rem   Assigning the result of a comparison to a variable
>  okay=a>=1 and a<=10
>  
>  rem   Use a variable within an if-statement
>  if (not okay) error "Wrong, wrong !"
>  
>     So  conditions  and expressions are really the same thing (at least as
>     long  as  yabasic  is  concerned).  Therefore the terms conditions and
>     expression  can really be used interchangeably, at least in theory. In
>     reality  the  term  condition  is  used in connection with if or while
>     whereas  the  term  expression  tends  to  be  used  more often within
>     arithmetic context.
>  
>  References on arrays
>  
>     References  on arrays are the only way to refer to an array as a whole
>     and to pass it to subroutines or functions like arraydim or arraysize.
>     Whereas  (for example) a(2) designates the second element of the array
>     a, a() (with empty braces) refers to the array a itself. a() is called
>     an array reference.
>  
>     If  you  pass  an  array reference to one of your own subroutines, you
>     need to be aware, that the subroutine will be able to modify the array
>     you  have  passed  in. So passing an array reference does not create a
>     copy of the array; this has some interesting consequences:
>       * Speed  and space: Creating a copy of an array would be a time- and
>         resourceconsuming operation; passing just a reference is cheap and
>         fast.
>       * Returning  many values: A subroutine, that wants to give back more
>         than one value, may require an array reference among its arguments
>         and  then  store its many return values within this array. This is
>         the only way to return more than one value from a subroutine.
>  
>  Specifying Filenames under Windows
>  
>     As  you  probably know, windows uses the character '\\' to separate the
>     directories    within    a    pathname;    an    example    would   be
>     C:\\yabasic\\yabasic.exe (the usual location of the yabasic executable).
>     However,  the  very  same  character  '\\' is used to contstruct escape
>     sequences,   not  only  in  yabasic  but  in  most  other  programming
>     languages.
>  
>     Therefore the string "C:\\t.dat" does not specify the file t.dat within
>     the directory C:; this is because the sequence '\\t' is translated into
>     the  tab-character.  To  specify  this  filename,  you need to use the
>     string "C:\\\\t.dat" (note the double slash '\\\\').
>  
>  Escape-sequences
>  
>     Escape-sequences   are  the  preferred  way  of  specifying  'special'
>     characters. They ar intoduced by the '\\'-character and followed by one
>     of a few regular letters, e.g. '\\n' or '\\r' (see the table below).
>  
>     Escape-sequences may occur within any string at any position; they are
>     replaced  at  parsetime  (opposed to runtime), i.e. as soon as yabasic
>     discovers the string, with their corresponding special character. As a
>     consequence of this len("\\a") returns 1, because yabasic replaces "\\a"
>     with the matching special character just before the program executes.
>  
>     Table 6.1. Escape sequences
>     Escape Seqence  Matching special character
>     \\n             newline
>     \\t             tabulator
>     \\v             vertical tabulator
>     \\b             backspace
>     \\r             carriage return
>     \\f             formfeed
>     \\a             alert (i.e. a beeping sound)
>     \\\\             backslash
>     \\'             single quote
>     \\"             double quote
>     \\xHEX          chr$(HEX) (see below)
>  
>     Note,  that an escape sequences of the form \\xHEX allows one to encode
>     arbitrary  characters  as  long  as  you  know  their  position  (as a
>     hex-number) within the ascii-charset: For example \\x012 is transformed
>     into  the  character  chr$(18)  (or  chr$(dec("12",16)).  Note that \\x
>     requires  a  hexa-decimal  number  (and  the  hexa-decimal string "12"
>     corresponds to the decimal number 18).
>  
>  Chapter 7. A few example programs
>  
>     Table of Contents
>  
>     A very simple program
>     A part of the demo of yabasic
>  
>  A very simple program
>  
>     The program below is a very simple program:
>  repeat
>    input "Please enter the first number, to add " a
>    input "Please enter the second number, to add " b
>    print a+b
>  until(a=0 and b=0)
>  
>     This  program requests two numbers, which it than adds. The process is
>     repeated until you enter zero (or nothing) twice.
>  
>  A part of the demo of yabasic
>  
>     The  listing below is an abbreviated and slightly refreshed version of
>     the demo of yabasic. However this demo has been written before some of
>     the  more  advanced  features  of  yabasic  have been implemented. For
>     example subroutines have only been retrofitted on the original version
>     of  this demo. So please do not take this as a particular good example
>     of yabasic-code. On the other hand: This is no beauty contest. However
>     you  could  make it one, if you send me some better code (which should
>     do nice and simple things with less than 200 lines).
>  
>  //
>  //      This program demoes yabasic
>  //
>  
>  
>  //      Check, if screen is large enough
>  clear screen
>  sw=peek("screenwidth"):sh=peek("screenheight")
>  if (sw<78 or sh<24) then
>    print
>    print "  Sorry, but your screen is to small to run this demo !"
>    print
>    end
>  endif
>  sw=78:sh=24
>  
>  //  Initialize everything
>  restore mmdata
>  read mmnum:dim mmtext$(mmnum)
>  for a=1 to mmnum:read mmtext$(a):next a
>  
>  //  Main loop selection of demo
>  ysel=1
>  label mainloop
>  clear screen
>  print colour("cyan","magenta") at(7,2) "################################"
>  print colour("cyan","magenta") at(7,3) "################################"
>  print colour("cyan","magenta") at(7,4) "################################"
>  print colour("yellow","blue") at(8,3) " This is the demo for yabasic "
>  yoff=7
>  for a=1 to mmnum
>    if (a=mmnum) then ydisp=1:else ydisp=0:fi
>    if (a=ysel) then
>      print colour("blue","green") at(5,yoff+ydisp+a) mmtext$(a);
>    else
>      print at(5,yoff+ydisp+a) mmtext$(a);
>    endif
>  next a
>  print at(3,sh-3) "Move selection with CURSOR KEYS (or u and d),"
>  print at(3,sh-2) "Press RETURN or SPACE to choose, ESC to quit."
>  
>  
>  do    // loop for keys pressed
>    rev=1
>    do    // loop for blinking
>      k$=inkey$(0.4)
>      if (k$="") then
>        if (ysel=mmnum) then
>          if (rev=1) then 
>            print colour("blue","green") at(5,yoff+mmnum+1) mmtext$(mmnum);
>            rev=0
>          else
>            print colour("yellow","red") at(5,yoff+mmnum+1) mmtext$(mmnum);
>            rev=1
>          endif
>        endif
>      else    // key has been pressed, leave loop
>        break
>      endif
>    loop    // loop for blinking
>  
>    yalt=ysel
>    if (k$="up" or k$="u") then 
>      if (ysel=1) then ysel=mmnum else ysel=ysel-1 fi
>      redraw():heal():continue
>    fi
>    if (k$="down" or k$="d") then 
>      if (ysel=mmnum) then ysel=1 else ysel=ysel+1 fi
>      redraw():heal():continue
>    fi
>    if (k$=" " or k$="enter" or k$="right") then 
>      on ysel gosub overview,bitmap,endit,notyet
>      goto mainloop
>    fi
>    if (k$="esc") then
>      endit()
>    fi
>    beep
>    print at(3,sh-5) "Invalid key: ",k$,"         "
>  loop    // loop for keys pressed
>  
>  
>  //  redraw line
>  sub redraw()
>    if (yalt=mmnum) then ydisp=1:else ydisp=0:fi
>    print at(5,yoff+yalt+ydisp) mmtext$(yalt);
>    if (ysel=mmnum) then ydisp=1:else ydisp=0:fi
>    print colour("blue","green") at(5,yoff+ysel+ydisp) mmtext$(ysel);
>    return
>  end sub
>  
>  
>  //  erase a line
>  sub heal()
>    print at(3,sh-5) "                                                       "
>    return
>  end sub
>  
>  
>  //  Go here to exit
>  label endit
>    print at(3,sh-8) "Hope you liked it ...\\n   ";
>    exit
>  return
>  
>  
>  //  Present a short overview
>  label overview
>    clear screen
>    print "\\n  Yabasic is a quite traditional basic: It comes with"
>    print "  print, input, for-next-loops, goto, gosub, while and"
>    print "  repeat and even user defined procedures and libraries."
>    print "\\n  Yabasic has the usual functions, from sin(), int() to mid$();"
>    print "  more advanced functions are date$ (is ",date$,"),"
>    print "  or token$(), system$(), ran() and glob$()."
>    print "\\n  Yabasic makes it easy to open a window, draw lines"
>    print "  and print the resulting picture."
>    print "\\n  Yabasic programs are interpreted and run under Unix"
>    print "  and Windows. Yabasic is small (around 200k) and"
>    print "  free, i.e. subject to the GNU copyleft."
>    print "\\n  Finally, this demo itself is written in yabasic and"
>    print "  gives an idea of what can be done with the language."
>    print "\\n\\n\\n  While you read this, I am calculating prime numbers,"
>    print "  Press any key to return to main menu ..."
>    can=1
>    print at(6,19) "This is a prime number: "
>    label nextcan
>    can=can+2
>    for i=2 to sqrt(can):if (frac(can/i)=0) then goto notprime:fi:next i
>    print at(32,19) can;
>    label notprime
>    if (lower$(inkey$(0))<>"") then return:fi
>  goto nextcan
>  
>  
>  //  Show some animated bitmaps
>  label bitmap
>    clear screen
>    print at(5,5) "Yabasic offers limited support for bitmapped graphics."
>    print at(5,6) "You can retrieve and alter rectangular regions of"
>    print at(5,7) "the graphics window with a single command."
>    print reverse at(5,12) " Press any key to return to main menu ... "
>    n=20
>    open window 400,400
>    if (picsinitialized=0) then
>      picsinitialized=1
>      dim pics(n,4)
>      dim pics$(5)
>      restore pics
>      for a=1 to 5:read pics$(a):next a
>    endif
>    tick=1
>    for a=1 to n:pics(a,4)=0:next a
>    cx=ran(370):cy=ran(370):vx=10-ran(20):vy=10-ran(20)
>    label picloop
>      for a=1 to n
>        if (pics(a,4)<=tick) then
>          if (pics(a,4)=tick) then
>            bitblit pics$(pics(a,3)) to pics(a,1),pics(a,2),"xor"
>          endif
>          x=cx+50-ran(100):y=cy+50-ran(100)
>          if (ran(10)>3) then
>            pics(a,1)=x:pics(a,2)=y:pics(a,3)=ran(5)+1
>            pics(a,4)=tick+4+int(ran(4))
>      bitblit pics$(pics(a,3)) to pics(a,1),pics(a,2),"xor"          
>          endif
>        endif
>      next a
>      tick=tick+1
>      cx=cx+vx:cy=cy+vy
>      if (cx<-30 or cx>400) then cx=cx-vx:vx=-vx fi
>      if (cy<-30 or cy>400) then cy=cy-vy:vy=-vy fi
>    if (inkey$(0.1)="") then goto picloop fi
>    close window
>  return
>  
>  
>  //  data for bitmaps
>  label pics
>  data "24,24:00000000000000000000000008f1000eff000fff308f9f30cf0c70e30870e30070e
>  00070e07070e07870e0fc70e1ff30e1ff3ec1cf1ec3000fc700cf8f3cf78ffff30efff000ff00"
>  data "24,24:00c10000e10000f10000f10008f30008f30008f700fff700ffff30ffffffefffffe
>  fffff0ffff70eff700eff000cff100eff300fff70cfff70ef7ef1ef1cf3e700e3e100c3000000"
>  data "24,24:0000000000700e00700e00700e00700e10700e38700c38700c7c30087c3000fe100
>  0ff1000ef0000e70000c70000c30000c30000e10000f10000f0000c70000c70000c3000000000"
>  data "24,24:000000000000008700008f30008f7000cf7000c37000e97000f97000f83008f8300
>  878300cf8300ef8300efb300eef700fcf700f0f708700f0c700f1c300e1c100e1000000000000"
>  data "24,24:0000000000000cf1000cff000cff300cbf300c3c700838700c30700cff700cff700
>  cff700c9f700c1c700e10700e10700f38708fff708fff7083ff10000000000000000000000000"
>  
>  
>  //  Go here for a feature not yet implemented
>  label notyet
>    clear screen
>    print "\\n\\n  Sorry this section is not yet implemented !"
>    print "  Press any key to return to main menu ..."
>    inkey$
>  return
>  
>  
>  //  Data section ...
>  label mmdata
>  //  Data for main menu: Number and text of entries in main menu
>  data 3
>  data " Yabasic in a nutshell "
>  data " Animated Bitmaps "
>  data " Exit this demo "
>  
>     
>  
>  Chapter 8. The Copyright of yabasic
>  
>     yabasic  may be copied only under the terms of the Artistic License or
>     the  GNU  General  Public License (GPL), both of which are distributed
>     with yabasic.
>  
>     [Can't  you  make  up your mind ?!], I hear you say. Umm, well yes. In
>     fact  I  do not want to read or try to understand them both, so I have
>     put  the  burden  on  you  (grin).  However, I think that the Artistic
>     License  is  more  liberal  and  gives  you more rights and you should
>     choose it; on the other hand the GPL is more widely known and a lot of
>     software is distributed under its terms.
>  
>     Here  is  a  list  of  things that are possible under the terms of the
>     Artistic License:
>       * Put  yabasic  on  your  own homepage or CD and even charge for the
>         service of distributing yabasic.
>       * Write  your  own  yabasic-programs,  pack your program and yabasic
>         into a package and sell the whole thing.
>       * Modify  yabasic  and  add  or  remove  features, sell the modified
>         version.

.SH AUTHOR
Marc-Oliver Ihm, with the input and suggestions from
many others.
.SH "SEE ALSO"
yabasic.htm - for the hyperlinked version of the text that is presented above.

www.yabasic.de - for further information about yabasic.
.SH BUGS
Still some.

