<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <title>Some remarks on changing Yabasic</title>
    <link rel="stylesheet" type="text/css" href="standard.css">
    <meta name="author" content="Marc Ihm">

  </head>

  <h1>Some remarks on changing Yabasic</h1>
  <p>This document may serve as an introduction into the internals of yabasic. 
    It is aimed at anyone who wants to:</p>
  
  <ul>
    <li>Join the yabasic developer community</li>
    <li>Modify yabasic for his or her own purposes</li>
    <li>Learn how to build an interpreter</li>
  </ul>

  <p>If you just want to <em>use</em> yabasic, you do not need to read this page.
  <p>Right now this document is just a short draft in need of an update. But at
    least there is a table of contents:</p>
  
  <ul>
    <li><a href="#Tools">Tools needed to develop yabasic</a></li>
    <li><a href="#Files of Yabasic">Files of Yabasic</a></li>
    <li><a href="#Variables in yabasic">Variables in Yabasic</a></li>
    <li><a href="#An example">An Example: Adding the foo$()-function</a></li>
    <li><a href="# An second Example">An second Example: Adding the token()-function</a></li>
  </ul>

  <h2><a name="Tools">Tools</a></h2>
  <p>Lets make a list of tools needed to change or develop yabasic: 
    <ul type="disc">
      <li>Linux or Windows 95/98/2000/NT/XP/Vista/8/10 ...</li>
      <li>gcc if you use Linux, Visual C++ (community edition) for Windows</li>
      <li><a href="#Flex and Bison">Flex and Bison</a></li>
    </ul>

    <h2><a name="Flex and Bison">Flex and Bison</a></h2>
  <p>Flex and Bison are tools which accept specially formatted input files (yabasic.flex 
    and yabasic.bison) and emit C-code (flex.c and bison.c) which is compiled and 
    linked to the rest of yabasic. Both are GNU tools and come with their own documentation 
    in info format.</p>
  <p>With Flex you can define the <b>tokens</b> of yabasic. Tokens are the keywords 
    which constitute the skeleton of any yabasic program. &quot;if&quot;, &quot;print&quot;, 
    &quot;&lt;&quot; are examples of tokens. If you'd like to change yabasic to 
    accept &quot;whenever&quot; instead of &quot;if&quot;, you would need to tinker 
    with the Flex input-file (which is named yabasic.flex). After that you could 
    write &quot;whenever (a&lt;b) print a&quot; instead of &quot;if (a&lt;b) print 
    a&quot; in yabasic.</p>
  <p>The Bison input-file defines the <b>grammar</b> of yabasic. The grammar defines 
    how tokens (acknowledged by Flex) must be arranged to yield a valid yabasic 
    program. The grammar is a set of rules stating that &quot;if (a&lt;b) print 
    a&quot; is a valid yabasic statement, but &quot;print a if (a&lt;b)&quot; is 
    not. So if you think yabasic should understand &quot;print a if (a&lt;b)&quot; 
    you should try to change yabasic.bison.</p>
  <h2><a name="Files of Yabasic">Files of Yabasic</a></h2>
  <p>To get a valid yabasic executable you need to compile and link seven C-files, 
    which include two header-files; two of the C-files are generated by flex or 
    bison. Here they are all lumped together: 
    <ul type="disc">
      <li>yabasic.flex : input file to Flex, might be edited to add/change tokens.</li>
      Processing it with Flex produces: 
      <li>flex.c : produced by Flex, don't edit this file, rather change yabasic.flex</li>
      
      <li>yabasic.bison : input file to bison, might be edited to change the grammar.</li>
      Processing it with Bison produces: 
      <li>bison.c : produced by bison from yabasic.bison.</li>
      <li>io.c : code related with input/output, e.g. &quot;print&quot;, &quot;input&quot;.</li>
      
      <li>graphic.c : all about grafics and printing of grafics.</li>
      <li>main.c : main() function of yabasic, other stuff ...</li>
      <li>symbol.c : functions to create, store and retrieve symbols in yabasic.</li>
      <li>flow.c : functions flow-control (e.g. case-statement or loops).</li>

      <li>wherami.c : code to find out the location of the yabasic executable. Written by Gregory Pakosz.</li>
      
    </ul>
  <p>So lets have a close look at some of them:&nbsp;</p>
  <p><i>To be continued ...</i></p>

  <h2><a name="Variables in yabasic">Variables in yabasic</a></h2>
  <p>Here are some remarks about how yabasic organises its variables.</p>
  <h3>Overview</h3>
  <p>Yabasic keeps lists of all its variables (e.g. foo, bar$ as well as arrays). 
    There is one list for all variables used within the (main) program and one list 
    for each subroutine. The variable list for a subroutines is created, as soon 
    as yabasic starts executing a subroutine and it is removed as soon as the subroutine 
    is left. There will be many lists a any given time, because one subroutine may 
    call another (or even itself).</p>
  <p>At the beginning of the execution of a program (or subroutine), the corresponding 
    variable list is empty until any statement references a variable (e.g. a=2). 
    In this moment yabasic searches the list for a variable named &quot;a&quot; 
    and will not find id (as the list is empty initially). Instead of complaining, 
    yabasic will just create the variable &quot;a&quot; (with an initial value of 
    0).</p>
  <p>Unfortunately this process of searching a variable within a list of variables 
    is quite slow; to speed up things, yabasic remembers the location of each variable 
    and stores it along with the command which references the variable. I.e. the 
    internal representation of the command &quot;a=2&quot; would store not only 
    the name of the variable &quot;a&quot;, but also the exact position of this 
    variable within yabasic's list of variables. The next time this command is executed, 
    the variable need not be searched again, and access is quite fast.</p>
  <p>However, this scheme is not perfect: Consider a subroutine; as said before 
    each subroutine has its own list of variables (which keeps the variables local 
    to this subroutine and all parameters). Therefore, if yabasic needs to find 
    a variable within a subroutine, it searches within the local list of variables 
    (and adds it there if necessary). And again, the location of the variable is 
    stored with the command to speed up the next access. Now if the subroutine is 
    done the local list of variables is removed, and therefore all references to 
    those variables have to be invalidated, because the variables which they refer 
    to are gone. Next time the subroutine is called, each variable has to be searched 
    (and maybe created) again. So there is some time overhead in calling subroutines 
    from within yabasic; however, this overhead should generally be made up by the 
    improvement in program logic and readbility which can be achieved by using subroutines.</p>
  <h3>Routines and structures</h3>
  <p>Handling of variables is so important that nearly the whole source file <b>symbol.c 
      &nbsp;</b>deals with this topic; the relevant structures however are defined 
    in <b>yabasic.h</b>:</p>
  <p><b>struct symbol</b> is the C-structure, which may store any variable (=symbol): 
    numbers, strings or arrays. It has room to store a double value as well as a 
    pointer to a string or to the elements of an array (for any given symbol only 
    one of those is actually used). Furthermore it has pointers to be kept in a 
    list of symbols associated with the main program or a subroutine.</p>
  <p><b>struct symstack</b> is used to keep the many lists of variables (=symbols), 
    which might be active at any given time. Elements of type <b>struct symstack</b> 
    form a linked list and each forms the head of a list of variables (elements 
    of type struct symbol).</p>
  <p>A list of variables is created by the function <b>pushsymlist()</b>; as soon 
    as the subroutine to which the list belongs is done, the list is removed by 
    <b>popsymlist()</b>. popsymlist() calls <b>freesym()</b> fro each symbol to 
    free any memory associated with this symbol. The most important function however 
    is <b>get_sym()</b> which searches the different lists of variables and searches 
    for a named symbol; if the symbol is not found it might be created. The detailed 
    behaviour of get_sym() is defined by the parameter <b>add</b>, which is of type 
    <b>addmodes</b> (as defined in yabasic.h). It specifies, if an unknown symbol 
    should be added, or an error should be returned; and if an unknown symbol is 
    added, it might be added as a local or a global variable depending on the value 
    of <b>add</b>.</p>

  <h2><a name="An example">An example: Adding the foo$() function</a></h2>
  <p>In this example we will learn the steps necessary to add a new function to 
    yabasic. The function foo$() serves as an example: It takes a single numeric 
    argument and returns a string consisting of as many repetitions of the string 
    &quot;foo&quot; as specified in the argument; i.e. foo$(2) would return &quot;foofoo&quot;, 
    which is quite silly but enough to learn the necessary steps.</p>
  <p>Yabasic already has quite a bunch of functions so we may follow the path 
    of some existing function, when adding our new function foo$(). A suitable function 
    would be str$(), which takes a numeric argument and returns a string just as 
    our prospected function foo$().</p>
  <p>Assuming, that you are using linux (or some other Unix), do the following: 

    <ul type="disc">
      <li>Edit the file &quot;yabasic.flex&quot; ; add the line 
	<pre>&nbsp;&quot;FOO$&quot; return tFOO;</pre>
      <li>You may not add this line anywhere; &quot;yabasic.flex&quot; consists 
	of several regions and you have to add this line to the right region: Just 
	search for tSTR to find the place where the str$()-function is defined; 
	foo$() may be defined there too.<br> The new line advises the flex-tokenizer 
	(the C-File generated by flex) to return the integer constant tFOO , whenever 
	it finds the string &quot;FOO$&quot;. 
      <li>The integer constant tFOO has been used above but not defined yet ! 
	To do this, edit the file &quot;yabasic.bison&quot;: Search for the region 
	of lines starting with &quot;%token&quot; and add to one of these lines 
	&quot;tFOO&quot; (again you may seek the proximity of tSTR, for consistency). 
	
      <li>Still in file &quot;yabasic.bison&quot; search the region where string 
	functions are defined: search for &quot;string_function:&quot; and add this 
	line: 
	<pre>| tFOO '(' expression ')' {create_function(fFOO);}</pre>
      <li>This line says, that a string_function (apart from the alternatives 
	defined in the surrounding lines) may start with the token tFOO followed 
	by a (numerical) expression in round braces. If a yabasic program contains 
	this new function foo$(), the code in curly braces ( create_function(fFOO); 
	) will be executed. These are all changes necessary for &quot;yabasic.bison&quot; 
	. 
      <li>The line above contained the constant fFOO which is not yet defined; 
	open &quot;yabasic.h&quot; and search for the string &quot;enum functions&quot;. 
	This enumeration defines all the functions known to yabasic, so you have 
	to add fFOO here. Note, that there are special entries fZEROARGS, fONEARG, 
	fTWOARGS, ... as our function fFOO accepts just a single argument, we have 
	to add fFOO between fZEROARGS and fONEARG ; we may add fFOO just behind 
	fSTR as both functions accept a single argument. That's all there is to 
	&quot;yabasic.h&quot; 
      <li>Now we have added almost everything but the code which actually performs 
	the work. Functions are defined in the file (surprise !) function.c . Open 
	this file and go to the function &quot;function()&quot; . function() consists 
	mostly of a large switch-block, where we have to add a case statement for 
	out foo()-function. A possible implementation would be: 
	<pre>case fFOO:<br>
	  pointer=my_foo((int) a1-&gt;value);
	  result=stSTRING;
	  break;</pre>
      <li>Most of the work is done in the function my_foo() (see below for a possible 
	definition). The argument which has been passed to fFOO is available through 
	the pointer a1, which points to a structure of type &quot;struct stackentry&quot; 
	(further arguments would be in a2, a3). If the argument passed to foo() 
	is a numeric value, this value is contained in a1-&gt;value (a string value 
	would be in a1-&gt;pointer). So we just have to pass a1-&gt;value to my_foo(), 
	which does the real work. my_foo() returns a pointer to a string, which 
	we save in the variable &quot;pointer&quot; ; moreover we remember its type 
	as stSTRING (the enumeration &quot;enum stackentries&quot; in yabasic.h 
	defines the types of values which may be pushed onto the internal stack). 
	That's all and so we break out of the switch statement. Now we just have 
	to add the function my_foo() to function.c: 
	<pre>char *my_foo(int mult) {
	  char *res;
	  if (mult&lt;0) {
	  error(ERROR,&quot;negative values not allowed for function foo()&quot;); 
	  return my_strdup(&quot;&quot;); 
	  } 
	  res=my_malloc(mult*4+1); 
	  res[0]='\0'; 
	  for(i=0;i&lt;mult;i++) strcat(res,&quot;foo&quot;) 
	  return res;
	  }</pre>
      <li>The prototype for this function can be added at the top of function.h 
	(after the comment /* -------- local functions ---------*/): 
	<pre>char *my_foo(int);</pre>
      <li>A few words regarding the implementation of the function foo():<br> 
	
	<ul type="disc">
          <li>error() is the standard function used to report an ERROR, a WARNING,NOTE 
            or FATAL. 
          <li>my_malloc() is just a wrapper around the usual malloc(), which returns 
            a pointer to the requested memory area. If no more memory can be allocated, 
            a FATAL is issued, and the function does not return at all. Therefore 
            it is not necessary to check for the return value of my_malloc(). 
	</ul>
      <li>Now you just have to put it all together, use make to process all the 
	changed files: 
	<pre>make flex
	  make bison
	  make&nbsp;</pre>
    </ul>
  <p>That's it ! Now all files are up to date. The new built of yabasic knows 
    about the foo$()-function and is ready for extensive testing :-) </p>
  <h1><a name=" An second Example">&nbsp;An second Example: Adding the token()-function 
  </a></h1>
  <p>This example is considerably shorter than the <a href="#An example">first 
      one</a>, which you should have read in advance. Here you see how to implement 
    the token()-function, which is already present in yabasic, so you may have a 
    look at the sources for any details. You may use the token()-function like this:</p>
  <ul>
    <pre>dim w$(1)<br>
      n=split(&quot;one::two:thre::four&quot;,w$(),&quot;:&quot;)
      print n</pre>
  </ul>
  <p>The array-parameter is the most interesting thing about the token()-function, 
    so we will see how it is handled. The definitions in &quot;yabasic.flex&quot; 
    are quite standard: see the first example for details about the necessary modifications. 
    Therefore we will have a look at the definition in &quot;yabasic.bison&quot;:</p>
  <ul>
    <pre>&nbsp;&nbsp;| tTOKEN '(' string_expression ',' string_arrayref ',' string_expression ')' {add_command(cTOKEN2,NULL);}
      &nbsp;&nbsp;| tTOKEN '(' string_expression string_arrayref ',' ')' {add_command(cTOKEN,NULL);}
      &nbsp;&nbsp;| tSPLIT '(' string_expression ',' string_arrayref ',' string_expression ')' {add_command(cSPLIT2,NULL);}
      &nbsp;&nbsp;| tSPLIT '(' string_expression string_arrayref ',' ')' {add_command(cSPLIT,NULL);}
      &nbsp;&nbsp;</pre>
  </ul>
  <p>Note that token() and split() are defined twice, because each comes in two 
    variants: With either two or three parameters (e.g. token(&quot;one::two&quot;,a$()) 
    and token(&quot;one::two&quot;,a$(),&quot;:&quot;) ). These lines extend the 
    definition of a yabasic-function (search for the string &quot;function:&quot;). 
    All functions in yabasic are defined in the same region of the &quot;yabasic.bison&quot;. 
    Most of these lines contain a create_function()-statement (e.g. create_function(fSIN) 
    ): This is the easiest way to define a function in yabasic (as you may see in 
    the <a href="#An example">first example</a>). However, token() and split() require 
    a reference to an array among their arguments, which is uncommon for yabasic-functions, 
    and therefore special commands (cTOKEN, cTOKEN2, cSPLIT, cSPLIT2) have been 
    added. These commands then have to handle the array reference which is passed 
    on the stack of yabasic. But before examining those functions more closely, 
    we have to check the definition of string_arrayref, which appears in the lines 
    above. Within &quot;yabasic.bison&quot; you will find:</p>
  <ul>
    <pre>string_arrayref: tSTRSYM '(' ')' {create_pusharrayref(dotify($1,FALSE),stSTRINGARRAYREF);}</pre>
  </ul>
  <p>This tells us, that an array reference is just a string symbol (e.g. foo$) 
    followed by a pair of braces, i.e. something like foo$() . If such an array 
    reference is found, the create_pusharrayref() is called; it is defined in symbol.c:</p>
  <ul>
    <pre>void create_pusharrayref(char *name,int type) /* create command 'cPUSHARRAYREF' */<br>
      {<br>
      &nbsp;&nbsp;struct command *cmd;
      &nbsp;&nbsp;cmd=add_command(cPUSHARRAYREF,name);
      &nbsp;&nbsp;cmd-&gt;args=type;
      }
      &nbsp;
      void pusharrayref(struct command *cmd) /* push an array reference onto stack */
      {
      &nbsp;&nbsp;struct stackentry *s;
      &nbsp;&nbsp;s=push();
      &nbsp;&nbsp;s-&gt;type=cmd-&gt;args;
      &nbsp;&nbsp;s-&gt;pointer=my_strdup(cmd-&gt;name);
      }</pre>
  </ul>
  <pre>&nbsp;
    create_pusharrayref() does nothing special, it just calls add_command() and 
    stores the name of the array (e.g. foo$() ) reference and its expected type 
    (reference to a numeric or a string array). create_pusharrayref() is called 
    during parsing/compilation of the yabasic-program, wheras pusharrayref() is 
    called during execution (you may search in &quot;main.c&quot; for &quot;pusharrayref()&quot; 
    to see how it is called). pusharrayref() is quite trivial: It just takes the 
    name of the array (e.g. foo$() ) and pushes it onto the yabasic stack, where 
    it is ready to be used by token(). Lets look at some of the code defined in 
    &quot;function.c&quot;:
    &nbsp;</pre>
  <ul>
    <pre>&nbsp;
      
      void token(struct command *cmd) /* extract token from variable */
      {
      &nbsp;&nbsp;int split;
      &nbsp;&nbsp;struct stackentry *s;
      &nbsp;&nbsp;struct symbol *sym;
      &nbsp;&nbsp;struct array *ar;                <i>..... some definitions omitted .....</i>
      &nbsp;&nbsp;int num=0,i;
      &nbsp;&nbsp;char *del,*line;
      &nbsp;&nbsp;
      &nbsp;&nbsp;if (cmd-&gt;type==cSPLIT2 || cmd-&gt;type==cTOKEN2)
      &nbsp;&nbsp;&nbsp;&nbsp;del=pop(stSTRING)-&gt;pointer;
      &nbsp;&nbsp;else
      &nbsp;&nbsp;&nbsp;&nbsp;del=&quot; \t&quot;;                                     
      <i>..... one line omitted .....</i>
      &nbsp;&nbsp;s=pop(stSTRINGARRAYREF);
      &nbsp;&nbsp;line=pop(stSTRING)-&gt;pointer;
      &nbsp;&nbsp;sym=get_sym(s-&gt;pointer,syARRAY,amSEARCH);
      &nbsp;&nbsp;if (!sym || !sym-&gt;pointer) {
      &nbsp;&nbsp;&nbsp;&nbsp;sprintf(string,&quot;array '%s()' is not defined&quot;,strip(s-&gt;pointer));
      &nbsp;&nbsp;&nbsp;&nbsp;error(ERROR,string);
      &nbsp;&nbsp;&nbsp;&nbsp;goto token_done;
      &nbsp;&nbsp;}
      &nbsp;&nbsp;ar=sym-&gt;pointer;
      &nbsp;&nbsp;if (ar-&gt;dimension&gt;1) {
      &nbsp;&nbsp;&nbsp;&nbsp;error(ERROR,&quot;only one dimensional arrays allowed&quot;);
      &nbsp;&nbsp;&nbsp;&nbsp;goto token_done;
      &nbsp;&nbsp;}
      &nbsp;
      ..... Many lines omitted .....
      &nbsp;
      token_done:     
      &nbsp; s=push();
      &nbsp; s-&gt;type=stNUMBER;
      &nbsp; s-&gt;value=num;
      }</pre>
  </ul>
  <p>Depending on the command (cTOKEN, cTOKEN2, cSPLIT or cSPLIT2) there are two 
    or three parameters on the stack ( token(&quot;one::two&quot;,a$()) and token(&quot;one::two&quot;,a$(),&quot;:&quot;) 
    both are valid ); therefore the string with delimiters (&quot;del&quot;) is 
    either popped from the stack or preset with a default value (&quot; \t&quot;). 
  </p>
  <p>Next (and more interesting) an element of type stSTRINGARRAYREF is popped 
    from the stack; this is just the name of the array (e.g. foo$() ), which has 
    been pushed onto the stack before within pusharrayref() . The next step is to 
    get the symbol which represents the array (see <a href="#Variables in yabasic">above</a> 
    for details on variables and symbols); this is done with get_sym(), which returns 
    a pointer sym to a symbol structure (as defined in yabasic.h). If get_sym() 
    returns NULL, the array (e.g. foo$() ) has not been defined. The symbol sym 
    in turn contains a multi-purpose pointer (sym-&gt;pointer) which points to an 
    array structure (as defined in yabasic.h). This pointer is assigned to the variable 
    ar.</p>
  <p>Now everything is prepared to do real work: A first step is to check, if 
    the array, which has been passed is a one-dimensional array as expected. The 
    next few lines of the token()-function are omitted: They split the string (pointed 
    to by the variable line) into tokens and calculate the number of tokens within 
    the variable num. This number is the result of the yabasic-function token() 
    and is finally pushed onto the stack.</p>
</body>

</html>
